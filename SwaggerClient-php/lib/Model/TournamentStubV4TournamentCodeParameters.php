<?php
/**
 * TournamentStubV4TournamentCodeParameters
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Riot API
 *
 * OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## Download OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([download file](../openapi-3.0.0.json), [view ui](?openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([download file](../openapi-3.0.0.min.json), [view ui](?openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([download file](../openapi-3.0.0.yml), [view ui](?openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([download file](../openapi-3.0.0.min.yml), [view ui](?openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([download file](../swaggerspec-2.0.json), [view ui](?swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([download file](../swaggerspec-2.0.min.json), [view ui](?swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([download file](../swaggerspec-2.0.yml), [view ui](?swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([download file](../swaggerspec-2.0.min.yml), [view ui](?swaggerspec-2.0.min.yml)) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.org/MingweiSamuel/riotapi-schema/builds) daily. ***
 *
 * OpenAPI spec version: dfa1c0f97b9cc62a43c9fb91daa1b91b3e9485c2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.7
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * TournamentStubV4TournamentCodeParameters Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TournamentStubV4TournamentCodeParameters implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'tournament-stub-v4.TournamentCodeParameters';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'spectator_type' => 'string',
        'team_size' => 'int',
        'pick_type' => 'string',
        'allowed_summoner_ids' => 'string[]',
        'map_type' => 'string',
        'metadata' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'spectator_type' => null,
        'team_size' => 'int32',
        'pick_type' => null,
        'allowed_summoner_ids' => null,
        'map_type' => null,
        'metadata' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'spectator_type' => 'spectatorType',
        'team_size' => 'teamSize',
        'pick_type' => 'pickType',
        'allowed_summoner_ids' => 'allowedSummonerIds',
        'map_type' => 'mapType',
        'metadata' => 'metadata'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'spectator_type' => 'setSpectatorType',
        'team_size' => 'setTeamSize',
        'pick_type' => 'setPickType',
        'allowed_summoner_ids' => 'setAllowedSummonerIds',
        'map_type' => 'setMapType',
        'metadata' => 'setMetadata'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'spectator_type' => 'getSpectatorType',
        'team_size' => 'getTeamSize',
        'pick_type' => 'getPickType',
        'allowed_summoner_ids' => 'getAllowedSummonerIds',
        'map_type' => 'getMapType',
        'metadata' => 'getMetadata'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const SPECTATOR_TYPE_NONE = 'NONE';
    const SPECTATOR_TYPE_LOBBYONLY = 'LOBBYONLY';
    const SPECTATOR_TYPE_ALL = 'ALL';
    const PICK_TYPE_BLIND_PICK = 'BLIND_PICK';
    const PICK_TYPE_DRAFT_MODE = 'DRAFT_MODE';
    const PICK_TYPE_ALL_RANDOM = 'ALL_RANDOM';
    const PICK_TYPE_TOURNAMENT_DRAFT = 'TOURNAMENT_DRAFT';
    const MAP_TYPE_SUMMONERS_RIFT = 'SUMMONERS_RIFT';
    const MAP_TYPE_TWISTED_TREELINE = 'TWISTED_TREELINE';
    const MAP_TYPE_HOWLING_ABYSS = 'HOWLING_ABYSS';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSpectatorTypeAllowableValues()
    {
        return [
            self::SPECTATOR_TYPE_NONE,
            self::SPECTATOR_TYPE_LOBBYONLY,
            self::SPECTATOR_TYPE_ALL,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPickTypeAllowableValues()
    {
        return [
            self::PICK_TYPE_BLIND_PICK,
            self::PICK_TYPE_DRAFT_MODE,
            self::PICK_TYPE_ALL_RANDOM,
            self::PICK_TYPE_TOURNAMENT_DRAFT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMapTypeAllowableValues()
    {
        return [
            self::MAP_TYPE_SUMMONERS_RIFT,
            self::MAP_TYPE_TWISTED_TREELINE,
            self::MAP_TYPE_HOWLING_ABYSS,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['spectator_type'] = isset($data['spectator_type']) ? $data['spectator_type'] : null;
        $this->container['team_size'] = isset($data['team_size']) ? $data['team_size'] : null;
        $this->container['pick_type'] = isset($data['pick_type']) ? $data['pick_type'] : null;
        $this->container['allowed_summoner_ids'] = isset($data['allowed_summoner_ids']) ? $data['allowed_summoner_ids'] : null;
        $this->container['map_type'] = isset($data['map_type']) ? $data['map_type'] : null;
        $this->container['metadata'] = isset($data['metadata']) ? $data['metadata'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['spectator_type'] === null) {
            $invalidProperties[] = "'spectator_type' can't be null";
        }
        $allowedValues = $this->getSpectatorTypeAllowableValues();
        if (!is_null($this->container['spectator_type']) && !in_array($this->container['spectator_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'spectator_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['team_size'] === null) {
            $invalidProperties[] = "'team_size' can't be null";
        }
        if (($this->container['team_size'] > 5)) {
            $invalidProperties[] = "invalid value for 'team_size', must be smaller than or equal to 5.";
        }

        if (($this->container['team_size'] < 1)) {
            $invalidProperties[] = "invalid value for 'team_size', must be bigger than or equal to 1.";
        }

        if ($this->container['pick_type'] === null) {
            $invalidProperties[] = "'pick_type' can't be null";
        }
        $allowedValues = $this->getPickTypeAllowableValues();
        if (!is_null($this->container['pick_type']) && !in_array($this->container['pick_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'pick_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['map_type'] === null) {
            $invalidProperties[] = "'map_type' can't be null";
        }
        $allowedValues = $this->getMapTypeAllowableValues();
        if (!is_null($this->container['map_type']) && !in_array($this->container['map_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'map_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets spectator_type
     *
     * @return string
     */
    public function getSpectatorType()
    {
        return $this->container['spectator_type'];
    }

    /**
     * Sets spectator_type
     *
     * @param string $spectator_type The spectator type of the game.              (Legal values:  NONE,  LOBBYONLY,  ALL)
     *
     * @return $this
     */
    public function setSpectatorType($spectator_type)
    {
        $allowedValues = $this->getSpectatorTypeAllowableValues();
        if (!in_array($spectator_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'spectator_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['spectator_type'] = $spectator_type;

        return $this;
    }

    /**
     * Gets team_size
     *
     * @return int
     */
    public function getTeamSize()
    {
        return $this->container['team_size'];
    }

    /**
     * Sets team_size
     *
     * @param int $team_size The team size of the game. Valid values are 1-5.
     *
     * @return $this
     */
    public function setTeamSize($team_size)
    {

        if (($team_size > 5)) {
            throw new \InvalidArgumentException('invalid value for $team_size when calling TournamentStubV4TournamentCodeParameters., must be smaller than or equal to 5.');
        }
        if (($team_size < 1)) {
            throw new \InvalidArgumentException('invalid value for $team_size when calling TournamentStubV4TournamentCodeParameters., must be bigger than or equal to 1.');
        }

        $this->container['team_size'] = $team_size;

        return $this;
    }

    /**
     * Gets pick_type
     *
     * @return string
     */
    public function getPickType()
    {
        return $this->container['pick_type'];
    }

    /**
     * Sets pick_type
     *
     * @param string $pick_type The pick type of the game.              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
     *
     * @return $this
     */
    public function setPickType($pick_type)
    {
        $allowedValues = $this->getPickTypeAllowableValues();
        if (!in_array($pick_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'pick_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['pick_type'] = $pick_type;

        return $this;
    }

    /**
     * Gets allowed_summoner_ids
     *
     * @return string[]
     */
    public function getAllowedSummonerIds()
    {
        return $this->container['allowed_summoner_ids'];
    }

    /**
     * Sets allowed_summoner_ids
     *
     * @param string[] $allowed_summoner_ids Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
     *
     * @return $this
     */
    public function setAllowedSummonerIds($allowed_summoner_ids)
    {
        $this->container['allowed_summoner_ids'] = $allowed_summoner_ids;

        return $this;
    }

    /**
     * Gets map_type
     *
     * @return string
     */
    public function getMapType()
    {
        return $this->container['map_type'];
    }

    /**
     * Sets map_type
     *
     * @param string $map_type The map type of the game.              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
     *
     * @return $this
     */
    public function setMapType($map_type)
    {
        $allowedValues = $this->getMapTypeAllowableValues();
        if (!in_array($map_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'map_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['map_type'] = $map_type;

        return $this;
    }

    /**
     * Gets metadata
     *
     * @return string
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param string $metadata Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game.
     *
     * @return $this
     */
    public function setMetadata($metadata)
    {
        $this->container['metadata'] = $metadata;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


