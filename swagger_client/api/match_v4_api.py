# coding: utf-8

"""
    Riot API

     OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## Download OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([download file](../openapi-3.0.0.json), [view ui](?openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([download file](../openapi-3.0.0.min.json), [view ui](?openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([download file](../openapi-3.0.0.yml), [view ui](?openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([download file](../openapi-3.0.0.min.yml), [view ui](?openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([download file](../swaggerspec-2.0.json), [view ui](?swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([download file](../swaggerspec-2.0.min.json), [view ui](?swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([download file](../swaggerspec-2.0.yml), [view ui](?swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([download file](../swaggerspec-2.0.min.yml), [view ui](?swaggerspec-2.0.min.yml)) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.org/MingweiSamuel/riotapi-schema/builds) daily. ***   # noqa: E501

    OpenAPI spec version: dfa1c0f97b9cc62a43c9fb91daa1b91b3e9485c2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class MatchV4Api(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def match_v4_get_match(self, match_id, **kwargs):  # noqa: E501
        """Get match by match ID.  # noqa: E501

        Get match by match ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match(match_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int match_id: The match ID. (required)
        :return: MatchV4MatchDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.match_v4_get_match_with_http_info(match_id, **kwargs)  # noqa: E501
        else:
            (data) = self.match_v4_get_match_with_http_info(match_id, **kwargs)  # noqa: E501
            return data

    def match_v4_get_match_with_http_info(self, match_id, **kwargs):  # noqa: E501
        """Get match by match ID.  # noqa: E501

        Get match by match ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_with_http_info(match_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int match_id: The match ID. (required)
        :return: MatchV4MatchDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['match_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method match_v4_get_match" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'match_id' is set
        if ('match_id' not in params or
                params['match_id'] is None):
            raise ValueError("Missing the required parameter `match_id` when calling `match_v4_get_match`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'match_id' in params:
            path_params['matchId'] = params['match_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Riot-Token', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lol/match/v4/matches/{matchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MatchV4MatchDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def match_v4_get_match_by_tournament_code(self, tournament_code, match_id, **kwargs):  # noqa: E501
        """Get match by match ID and tournament code.  # noqa: E501

        Get match by match ID and tournament code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_by_tournament_code(tournament_code, match_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tournament_code: The tournament code. (required)
        :param int match_id: The match ID. (required)
        :return: MatchV4MatchDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.match_v4_get_match_by_tournament_code_with_http_info(tournament_code, match_id, **kwargs)  # noqa: E501
        else:
            (data) = self.match_v4_get_match_by_tournament_code_with_http_info(tournament_code, match_id, **kwargs)  # noqa: E501
            return data

    def match_v4_get_match_by_tournament_code_with_http_info(self, tournament_code, match_id, **kwargs):  # noqa: E501
        """Get match by match ID and tournament code.  # noqa: E501

        Get match by match ID and tournament code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_by_tournament_code_with_http_info(tournament_code, match_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tournament_code: The tournament code. (required)
        :param int match_id: The match ID. (required)
        :return: MatchV4MatchDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tournament_code', 'match_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method match_v4_get_match_by_tournament_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tournament_code' is set
        if ('tournament_code' not in params or
                params['tournament_code'] is None):
            raise ValueError("Missing the required parameter `tournament_code` when calling `match_v4_get_match_by_tournament_code`")  # noqa: E501
        # verify the required parameter 'match_id' is set
        if ('match_id' not in params or
                params['match_id'] is None):
            raise ValueError("Missing the required parameter `match_id` when calling `match_v4_get_match_by_tournament_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tournament_code' in params:
            path_params['tournamentCode'] = params['tournament_code']  # noqa: E501
        if 'match_id' in params:
            path_params['matchId'] = params['match_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Riot-Token', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MatchV4MatchDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def match_v4_get_match_ids_by_tournament_code(self, tournament_code, **kwargs):  # noqa: E501
        """Get match IDs by tournament code.  # noqa: E501

        Get match IDs by tournament code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_ids_by_tournament_code(tournament_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tournament_code: The tournament code. (required)
        :return: list[int]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.match_v4_get_match_ids_by_tournament_code_with_http_info(tournament_code, **kwargs)  # noqa: E501
        else:
            (data) = self.match_v4_get_match_ids_by_tournament_code_with_http_info(tournament_code, **kwargs)  # noqa: E501
            return data

    def match_v4_get_match_ids_by_tournament_code_with_http_info(self, tournament_code, **kwargs):  # noqa: E501
        """Get match IDs by tournament code.  # noqa: E501

        Get match IDs by tournament code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_ids_by_tournament_code_with_http_info(tournament_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tournament_code: The tournament code. (required)
        :return: list[int]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tournament_code']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method match_v4_get_match_ids_by_tournament_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tournament_code' is set
        if ('tournament_code' not in params or
                params['tournament_code'] is None):
            raise ValueError("Missing the required parameter `tournament_code` when calling `match_v4_get_match_ids_by_tournament_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tournament_code' in params:
            path_params['tournamentCode'] = params['tournament_code']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Riot-Token', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[int]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def match_v4_get_match_timeline(self, match_id, **kwargs):  # noqa: E501
        """Get match timeline by match ID.  # noqa: E501

        Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_timeline(match_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int match_id: The match ID. (required)
        :return: MatchV4MatchTimelineDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.match_v4_get_match_timeline_with_http_info(match_id, **kwargs)  # noqa: E501
        else:
            (data) = self.match_v4_get_match_timeline_with_http_info(match_id, **kwargs)  # noqa: E501
            return data

    def match_v4_get_match_timeline_with_http_info(self, match_id, **kwargs):  # noqa: E501
        """Get match timeline by match ID.  # noqa: E501

        Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_match_timeline_with_http_info(match_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int match_id: The match ID. (required)
        :return: MatchV4MatchTimelineDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['match_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method match_v4_get_match_timeline" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'match_id' is set
        if ('match_id' not in params or
                params['match_id'] is None):
            raise ValueError("Missing the required parameter `match_id` when calling `match_v4_get_match_timeline`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'match_id' in params:
            path_params['matchId'] = params['match_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Riot-Token', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lol/match/v4/timelines/by-match/{matchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MatchV4MatchTimelineDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def match_v4_get_matchlist(self, encrypted_account_id, **kwargs):  # noqa: E501
        """Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.  # noqa: E501

        Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_matchlist(encrypted_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str encrypted_account_id: The account ID. (required)
        :param list[int] champion: Set of champion IDs for filtering the matchlist.
        :param list[int] queue: Set of queue IDs for filtering the matchlist.
        :param list[int] season: Set of season IDs for filtering the matchlist.
        :param int end_time: The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
        :param int begin_time: The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
        :param int end_index: The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
        :param int begin_index: The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
        :return: MatchV4MatchlistDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.match_v4_get_matchlist_with_http_info(encrypted_account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.match_v4_get_matchlist_with_http_info(encrypted_account_id, **kwargs)  # noqa: E501
            return data

    def match_v4_get_matchlist_with_http_info(self, encrypted_account_id, **kwargs):  # noqa: E501
        """Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.  # noqa: E501

        Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.match_v4_get_matchlist_with_http_info(encrypted_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str encrypted_account_id: The account ID. (required)
        :param list[int] champion: Set of champion IDs for filtering the matchlist.
        :param list[int] queue: Set of queue IDs for filtering the matchlist.
        :param list[int] season: Set of season IDs for filtering the matchlist.
        :param int end_time: The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
        :param int begin_time: The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
        :param int end_index: The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
        :param int begin_index: The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
        :return: MatchV4MatchlistDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['encrypted_account_id', 'champion', 'queue', 'season', 'end_time', 'begin_time', 'end_index', 'begin_index']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method match_v4_get_matchlist" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'encrypted_account_id' is set
        if ('encrypted_account_id' not in params or
                params['encrypted_account_id'] is None):
            raise ValueError("Missing the required parameter `encrypted_account_id` when calling `match_v4_get_matchlist`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encrypted_account_id' in params:
            path_params['encryptedAccountId'] = params['encrypted_account_id']  # noqa: E501

        query_params = []
        if 'champion' in params:
            query_params.append(('champion', params['champion']))  # noqa: E501
            collection_formats['champion'] = 'csv'  # noqa: E501
        if 'queue' in params:
            query_params.append(('queue', params['queue']))  # noqa: E501
            collection_formats['queue'] = 'csv'  # noqa: E501
        if 'season' in params:
            query_params.append(('season', params['season']))  # noqa: E501
            collection_formats['season'] = 'csv'  # noqa: E501
        if 'end_time' in params:
            query_params.append(('endTime', params['end_time']))  # noqa: E501
        if 'begin_time' in params:
            query_params.append(('beginTime', params['begin_time']))  # noqa: E501
        if 'end_index' in params:
            query_params.append(('endIndex', params['end_index']))  # noqa: E501
        if 'begin_index' in params:
            query_params.append(('beginIndex', params['begin_index']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Riot-Token', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lol/match/v4/matchlists/by-account/{encryptedAccountId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MatchV4MatchlistDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
