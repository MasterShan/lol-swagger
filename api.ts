/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Riot API
 *  OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## Download OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([download file](../openapi-3.0.0.json), [view ui](?openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([download file](../openapi-3.0.0.min.json), [view ui](?openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([download file](../openapi-3.0.0.yml), [view ui](?openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([download file](../openapi-3.0.0.min.yml), [view ui](?openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([download file](../swaggerspec-2.0.json), [view ui](?swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([download file](../swaggerspec-2.0.min.json), [view ui](?swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([download file](../swaggerspec-2.0.yml), [view ui](?swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([download file](../swaggerspec-2.0.min.yml), [view ui](?swaggerspec-2.0.min.yml)) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.org/MingweiSamuel/riotapi-schema/builds) daily. *** 
 *
 * OpenAPI spec version: dfa1c0f97b9cc62a43c9fb91daa1b91b3e9485c2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://na1.api.riotgames.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * This object contains single Champion Mastery information for player and champion combination.
 * @export
 * @interface ChampionMasteryV4ChampionMasteryDTO
 */
export interface ChampionMasteryV4ChampionMasteryDTO {
    /**
     * Is chest granted for this champion or not in current season.
     * @type {boolean}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    chestGranted?: boolean;
    /**
     * Champion level for specified player and champion combination.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    championLevel?: number;
    /**
     * Total number of champion points for this player and champion combination - they are used to determine championLevel.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    championPoints?: number;
    /**
     * Champion ID for this entry.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    championId?: number;
    /**
     * Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    championPointsUntilNextLevel?: number;
    /**
     * Last time this champion was played by this player - in Unix milliseconds time format.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    lastPlayTime?: number;
    /**
     * The token earned for this champion to levelup.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    tokensEarned?: number;
    /**
     * Number of points earned since current level has been achieved.
     * @type {number}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    championPointsSinceLastLevel?: number;
    /**
     * Summoner ID for this entry. (Encrypted)
     * @type {string}
     * @memberof ChampionMasteryV4ChampionMasteryDTO
     */
    summonerId?: string;
}

/**
 * 
 * @export
 * @interface ChampionV3ChampionInfo
 */
export interface ChampionV3ChampionInfo {
    /**
     * 
     * @type {Array<number>}
     * @memberof ChampionV3ChampionInfo
     */
    freeChampionIdsForNewPlayers?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChampionV3ChampionInfo
     */
    freeChampionIds?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ChampionV3ChampionInfo
     */
    maxNewPlayerLevel?: number;
}

/**
 * 
 * @export
 * @interface ErrorStatus
 */
export interface ErrorStatus {
    /**
     * 
     * @type {number}
     * @memberof ErrorStatus
     */
    statusCode?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface LeagueV4LeagueEntryDTO
 */
export interface LeagueV4LeagueEntryDTO {
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueEntryDTO
     */
    queueType?: string;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueEntryDTO
     */
    summonerName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueEntryDTO
     */
    hotStreak?: boolean;
    /**
     * 
     * @type {LeagueV4MiniSeriesDTO}
     * @memberof LeagueV4LeagueEntryDTO
     */
    miniSeries?: LeagueV4MiniSeriesDTO;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4LeagueEntryDTO
     */
    wins?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueEntryDTO
     */
    veteran?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4LeagueEntryDTO
     */
    losses?: number;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueEntryDTO
     */
    rank?: string;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueEntryDTO
     */
    leagueId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueEntryDTO
     */
    inactive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueEntryDTO
     */
    freshBlood?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueEntryDTO
     */
    tier?: string;
    /**
     * Player's summonerId (Encrypted)
     * @type {string}
     * @memberof LeagueV4LeagueEntryDTO
     */
    summonerId?: string;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4LeagueEntryDTO
     */
    leaguePoints?: number;
}

/**
 * 
 * @export
 * @interface LeagueV4LeagueItemDTO
 */
export interface LeagueV4LeagueItemDTO {
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueItemDTO
     */
    summonerName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueItemDTO
     */
    hotStreak?: boolean;
    /**
     * 
     * @type {LeagueV4MiniSeriesDTO}
     * @memberof LeagueV4LeagueItemDTO
     */
    miniSeries?: LeagueV4MiniSeriesDTO;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4LeagueItemDTO
     */
    wins?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueItemDTO
     */
    veteran?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4LeagueItemDTO
     */
    losses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueItemDTO
     */
    freshBlood?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeagueV4LeagueItemDTO
     */
    inactive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueItemDTO
     */
    rank?: string;
    /**
     * Player's summonerId (Encrypted)
     * @type {string}
     * @memberof LeagueV4LeagueItemDTO
     */
    summonerId?: string;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4LeagueItemDTO
     */
    leaguePoints?: number;
}

/**
 * 
 * @export
 * @interface LeagueV4LeagueListDTO
 */
export interface LeagueV4LeagueListDTO {
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueListDTO
     */
    leagueId?: string;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueListDTO
     */
    tier?: string;
    /**
     * 
     * @type {Array<LeagueV4LeagueItemDTO>}
     * @memberof LeagueV4LeagueListDTO
     */
    entries?: Array<LeagueV4LeagueItemDTO>;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueListDTO
     */
    queue?: string;
    /**
     * 
     * @type {string}
     * @memberof LeagueV4LeagueListDTO
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface LeagueV4MiniSeriesDTO
 */
export interface LeagueV4MiniSeriesDTO {
    /**
     * 
     * @type {string}
     * @memberof LeagueV4MiniSeriesDTO
     */
    progress?: string;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4MiniSeriesDTO
     */
    losses?: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4MiniSeriesDTO
     */
    target?: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueV4MiniSeriesDTO
     */
    wins?: number;
}

/**
 * 
 * @export
 * @interface LolStatusV3Incident
 */
export interface LolStatusV3Incident {
    /**
     * 
     * @type {boolean}
     * @memberof LolStatusV3Incident
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Incident
     */
    createdAt?: string;
    /**
     * 
     * @type {number}
     * @memberof LolStatusV3Incident
     */
    id?: number;
    /**
     * 
     * @type {Array<LolStatusV3Message>}
     * @memberof LolStatusV3Incident
     */
    updates?: Array<LolStatusV3Message>;
}

/**
 * 
 * @export
 * @interface LolStatusV3Message
 */
export interface LolStatusV3Message {
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Message
     */
    severity?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Message
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Message
     */
    createdAt?: string;
    /**
     * 
     * @type {Array<LolStatusV3Translation>}
     * @memberof LolStatusV3Message
     */
    translations?: Array<LolStatusV3Translation>;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Message
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Message
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Message
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface LolStatusV3Service
 */
export interface LolStatusV3Service {
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Service
     */
    status?: string;
    /**
     * 
     * @type {Array<LolStatusV3Incident>}
     * @memberof LolStatusV3Service
     */
    incidents?: Array<LolStatusV3Incident>;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Service
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Service
     */
    slug?: string;
}

/**
 * 
 * @export
 * @interface LolStatusV3ShardStatus
 */
export interface LolStatusV3ShardStatus {
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3ShardStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3ShardStatus
     */
    regionTag?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3ShardStatus
     */
    hostname?: string;
    /**
     * 
     * @type {Array<LolStatusV3Service>}
     * @memberof LolStatusV3ShardStatus
     */
    services?: Array<LolStatusV3Service>;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3ShardStatus
     */
    slug?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LolStatusV3ShardStatus
     */
    locales?: Array<string>;
}

/**
 * 
 * @export
 * @interface LolStatusV3Translation
 */
export interface LolStatusV3Translation {
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Translation
     */
    locale?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Translation
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof LolStatusV3Translation
     */
    heading?: string;
}

/**
 * 
 * @export
 * @interface MatchV4MasteryDto
 */
export interface MatchV4MasteryDto {
    /**
     * 
     * @type {number}
     * @memberof MatchV4MasteryDto
     */
    masteryId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MasteryDto
     */
    rank?: number;
}

/**
 * 
 * @export
 * @interface MatchV4MatchDto
 */
export interface MatchV4MatchDto {
    /**
     * Please refer to the Game Constants documentation.
     * @type {number}
     * @memberof MatchV4MatchDto
     */
    seasonId?: number;
    /**
     * Please refer to the Game Constants documentation.
     * @type {number}
     * @memberof MatchV4MatchDto
     */
    queueId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchDto
     */
    gameId?: number;
    /**
     * Participant identity information.
     * @type {Array<MatchV4ParticipantIdentityDto>}
     * @memberof MatchV4MatchDto
     */
    participantIdentities?: Array<MatchV4ParticipantIdentityDto>;
    /**
     * The major.minor version typically indicates the patch the match was played on.
     * @type {string}
     * @memberof MatchV4MatchDto
     */
    gameVersion?: string;
    /**
     * Platform where the match was played.
     * @type {string}
     * @memberof MatchV4MatchDto
     */
    platformId?: string;
    /**
     * Please refer to the Game Constants documentation.
     * @type {string}
     * @memberof MatchV4MatchDto
     */
    gameMode?: string;
    /**
     * Please refer to the Game Constants documentation.
     * @type {number}
     * @memberof MatchV4MatchDto
     */
    mapId?: number;
    /**
     * Please refer to the Game Constants documentation.
     * @type {string}
     * @memberof MatchV4MatchDto
     */
    gameType?: string;
    /**
     * Team information.
     * @type {Array<MatchV4TeamStatsDto>}
     * @memberof MatchV4MatchDto
     */
    teams?: Array<MatchV4TeamStatsDto>;
    /**
     * Participant information.
     * @type {Array<MatchV4ParticipantDto>}
     * @memberof MatchV4MatchDto
     */
    participants?: Array<MatchV4ParticipantDto>;
    /**
     * Match duration in seconds.
     * @type {number}
     * @memberof MatchV4MatchDto
     */
    gameDuration?: number;
    /**
     * Designates the timestamp when champion select ended and the loading screen appeared, NOT when the game timer was at 0:00.
     * @type {number}
     * @memberof MatchV4MatchDto
     */
    gameCreation?: number;
}

/**
 * 
 * @export
 * @interface MatchV4MatchEventDto
 */
export interface MatchV4MatchEventDto {
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    eventType?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    towerType?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    ascendedType?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    killerId?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    levelUpType?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    pointCaptured?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof MatchV4MatchEventDto
     */
    assistingParticipantIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    wardType?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    monsterType?: string;
    /**
     * (Legal values:  CHAMPION_KILL,  WARD_PLACED,  WARD_KILL,  BUILDING_KILL,  ELITE_MONSTER_KILL,  ITEM_PURCHASED,  ITEM_SOLD,  ITEM_DESTROYED,  ITEM_UNDO,  SKILL_LEVEL_UP,  ASCENDED_EVENT,  CAPTURE_POINT,  PORO_KING_SUMMON)
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    type?: MatchV4MatchEventDto.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    skillSlot?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    victimId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    afterId?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    monsterSubType?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    laneType?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    itemId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    participantId?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchEventDto
     */
    buildingType?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    creatorId?: number;
    /**
     * 
     * @type {MatchV4MatchPositionDto}
     * @memberof MatchV4MatchEventDto
     */
    position?: MatchV4MatchPositionDto;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchEventDto
     */
    beforeId?: number;
}

/**
 * @export
 * @namespace MatchV4MatchEventDto
 */
export namespace MatchV4MatchEventDto {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CHAMPIONKILL = <any> 'CHAMPION_KILL',
        WARDPLACED = <any> 'WARD_PLACED',
        WARDKILL = <any> 'WARD_KILL',
        BUILDINGKILL = <any> 'BUILDING_KILL',
        ELITEMONSTERKILL = <any> 'ELITE_MONSTER_KILL',
        ITEMPURCHASED = <any> 'ITEM_PURCHASED',
        ITEMSOLD = <any> 'ITEM_SOLD',
        ITEMDESTROYED = <any> 'ITEM_DESTROYED',
        ITEMUNDO = <any> 'ITEM_UNDO',
        SKILLLEVELUP = <any> 'SKILL_LEVEL_UP',
        ASCENDEDEVENT = <any> 'ASCENDED_EVENT',
        CAPTUREPOINT = <any> 'CAPTURE_POINT',
        POROKINGSUMMON = <any> 'PORO_KING_SUMMON'
    }
}

/**
 * 
 * @export
 * @interface MatchV4MatchFrameDto
 */
export interface MatchV4MatchFrameDto {
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchFrameDto
     */
    timestamp?: number;
    /**
     * 
     * @type {{ [key: string]: MatchV4MatchParticipantFrameDto; }}
     * @memberof MatchV4MatchFrameDto
     */
    participantFrames?: { [key: string]: MatchV4MatchParticipantFrameDto; };
    /**
     * 
     * @type {Array<MatchV4MatchEventDto>}
     * @memberof MatchV4MatchFrameDto
     */
    events?: Array<MatchV4MatchEventDto>;
}

/**
 * 
 * @export
 * @interface MatchV4MatchParticipantFrameDto
 */
export interface MatchV4MatchParticipantFrameDto {
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    totalGold?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    teamScore?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    participantId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    currentGold?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    minionsKilled?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    dominionScore?: number;
    /**
     * 
     * @type {MatchV4MatchPositionDto}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    position?: MatchV4MatchPositionDto;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    xp?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchParticipantFrameDto
     */
    jungleMinionsKilled?: number;
}

/**
 * 
 * @export
 * @interface MatchV4MatchPositionDto
 */
export interface MatchV4MatchPositionDto {
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchPositionDto
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchPositionDto
     */
    x?: number;
}

/**
 * 
 * @export
 * @interface MatchV4MatchReferenceDto
 */
export interface MatchV4MatchReferenceDto {
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchReferenceDto
     */
    lane?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchReferenceDto
     */
    gameId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchReferenceDto
     */
    champion?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchReferenceDto
     */
    platformId?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchReferenceDto
     */
    season?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchReferenceDto
     */
    queue?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchV4MatchReferenceDto
     */
    role?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchReferenceDto
     */
    timestamp?: number;
}

/**
 * 
 * @export
 * @interface MatchV4MatchTimelineDto
 */
export interface MatchV4MatchTimelineDto {
    /**
     * 
     * @type {Array<MatchV4MatchFrameDto>}
     * @memberof MatchV4MatchTimelineDto
     */
    frames?: Array<MatchV4MatchFrameDto>;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchTimelineDto
     */
    frameInterval?: number;
}

/**
 * 
 * @export
 * @interface MatchV4MatchlistDto
 */
export interface MatchV4MatchlistDto {
    /**
     * 
     * @type {Array<MatchV4MatchReferenceDto>}
     * @memberof MatchV4MatchlistDto
     */
    matches?: Array<MatchV4MatchReferenceDto>;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchlistDto
     */
    totalGames?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchlistDto
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4MatchlistDto
     */
    endIndex?: number;
}

/**
 * 
 * @export
 * @interface MatchV4ParticipantDto
 */
export interface MatchV4ParticipantDto {
    /**
     * Participant statistics.
     * @type {MatchV4ParticipantStatsDto}
     * @memberof MatchV4ParticipantDto
     */
    stats?: MatchV4ParticipantStatsDto;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantDto
     */
    participantId?: number;
    /**
     * List of legacy Rune information. Not included for matches played with Runes Reforged.
     * @type {Array<MatchV4RuneDto>}
     * @memberof MatchV4ParticipantDto
     */
    runes?: Array<MatchV4RuneDto>;
    /**
     * Participant timeline data.
     * @type {MatchV4ParticipantTimelineDto}
     * @memberof MatchV4ParticipantDto
     */
    timeline?: MatchV4ParticipantTimelineDto;
    /**
     * 100 for blue side. 200 for red side.
     * @type {number}
     * @memberof MatchV4ParticipantDto
     */
    teamId?: number;
    /**
     * Second Summoner Spell id.
     * @type {number}
     * @memberof MatchV4ParticipantDto
     */
    spell2Id?: number;
    /**
     * List of legacy Mastery information. Not included for matches played with Runes Reforged.
     * @type {Array<MatchV4MasteryDto>}
     * @memberof MatchV4ParticipantDto
     */
    masteries?: Array<MatchV4MasteryDto>;
    /**
     * Highest ranked tier achieved for the previous season in a specific subset of queueIds, if any, otherwise null. Used to display border in game loading screen. Please refer to the Ranked Info documentation.              (Legal values:  CHALLENGER,  MASTER,  DIAMOND,  PLATINUM,  GOLD,  SILVER,  BRONZE,  UNRANKED)
     * @type {string}
     * @memberof MatchV4ParticipantDto
     */
    highestAchievedSeasonTier?: MatchV4ParticipantDto.HighestAchievedSeasonTierEnum;
    /**
     * First Summoner Spell id.
     * @type {number}
     * @memberof MatchV4ParticipantDto
     */
    spell1Id?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantDto
     */
    championId?: number;
}

/**
 * @export
 * @namespace MatchV4ParticipantDto
 */
export namespace MatchV4ParticipantDto {
    /**
     * @export
     * @enum {string}
     */
    export enum HighestAchievedSeasonTierEnum {
        CHALLENGER = <any> 'CHALLENGER',
        MASTER = <any> 'MASTER',
        DIAMOND = <any> 'DIAMOND',
        PLATINUM = <any> 'PLATINUM',
        GOLD = <any> 'GOLD',
        SILVER = <any> 'SILVER',
        BRONZE = <any> 'BRONZE',
        UNRANKED = <any> 'UNRANKED'
    }
}

/**
 * 
 * @export
 * @interface MatchV4ParticipantIdentityDto
 */
export interface MatchV4ParticipantIdentityDto {
    /**
     * Player information.
     * @type {MatchV4PlayerDto}
     * @memberof MatchV4ParticipantIdentityDto
     */
    player?: MatchV4PlayerDto;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantIdentityDto
     */
    participantId?: number;
}

/**
 * 
 * @export
 * @interface MatchV4ParticipantStatsDto
 */
export interface MatchV4ParticipantStatsDto {
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    firstBloodAssist?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    visionScore?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    magicDamageDealtToChampions?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    damageDealtToObjectives?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalTimeCrowdControlDealt?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    longestTimeSpentLiving?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk1Var1?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk1Var3?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk1Var2?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    tripleKills?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk3Var3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    nodeNeutralizeAssist?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk3Var2?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore9?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore8?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    kills?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore1?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore0?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore2?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore5?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore4?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore7?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    playerScore6?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk5Var1?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk5Var3?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk5Var2?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalScoreRank?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    neutralMinionsKilled?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    damageDealtToTurrets?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    physicalDamageDealtToChampions?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    nodeCapture?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    largestMultiKill?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk2Var2?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk2Var3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalUnitsHealed?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk2Var1?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk4Var1?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk4Var2?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk4Var3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    wardsKilled?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    largestCriticalStrike?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    largestKillingSpree?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    quadraKills?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    teamObjective?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    magicDamageDealt?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item2?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item0?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    neutralMinionsKilledTeamJungle?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item6?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item4?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item5?: number;
    /**
     * Primary path rune.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk1?: number;
    /**
     * Primary path keystone rune.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk0?: number;
    /**
     * Primary path rune.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk3?: number;
    /**
     * Primary path rune.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk2?: number;
    /**
     * Secondary path rune.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk5?: number;
    /**
     * Secondary path rune.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk4?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk3Var1?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    damageSelfMitigated?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    magicalDamageTaken?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    firstInhibitorKill?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    trueDamageTaken?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    nodeNeutralize?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    assists?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    combatPlayerScore?: number;
    /**
     * Primary rune path
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perkPrimaryStyle?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    goldSpent?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    trueDamageDealt?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    participantId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalDamageTaken?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    physicalDamageDealt?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    sightWardsBoughtInGame?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalDamageDealtToChampions?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    physicalDamageTaken?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalPlayerScore?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    win?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    objectivePlayerScore?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalDamageDealt?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    item1?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    neutralMinionsKilledEnemyJungle?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    deaths?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    wardsPlaced?: number;
    /**
     * Secondary rune path
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perkSubStyle?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    turretKills?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    firstBloodKill?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    trueDamageDealtToChampions?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    goldEarned?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    killingSprees?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    unrealKills?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    altarsCaptured?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    firstTowerAssist?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    firstTowerKill?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    champLevel?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    doubleKills?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    nodeCaptureAssist?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    inhibitorKills?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchV4ParticipantStatsDto
     */
    firstInhibitorAssist?: boolean;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk0Var1?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk0Var2?: number;
    /**
     * Post game rune stats.
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    perk0Var3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    visionWardsBoughtInGame?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    altarsNeutralized?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    pentaKills?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalHeal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    totalMinionsKilled?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantStatsDto
     */
    timeCCingOthers?: number;
}

/**
 * 
 * @export
 * @interface MatchV4ParticipantTimelineDto
 */
export interface MatchV4ParticipantTimelineDto {
    /**
     * Participant's calculated lane. MID and BOT are legacy values.              (Legal values:  MID,  MIDDLE,  TOP,  JUNGLE,  BOT,  BOTTOM)
     * @type {string}
     * @memberof MatchV4ParticipantTimelineDto
     */
    lane?: MatchV4ParticipantTimelineDto.LaneEnum;
    /**
     * 
     * @type {number}
     * @memberof MatchV4ParticipantTimelineDto
     */
    participantId?: number;
    /**
     * Creep score difference versus the calculated lane opponent(s) for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    csDiffPerMinDeltas?: { [key: string]: number; };
    /**
     * Gold for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    goldPerMinDeltas?: { [key: string]: number; };
    /**
     * Experience difference versus the calculated lane opponent(s) for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    xpDiffPerMinDeltas?: { [key: string]: number; };
    /**
     * Creeps for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    creepsPerMinDeltas?: { [key: string]: number; };
    /**
     * Experience change for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    xpPerMinDeltas?: { [key: string]: number; };
    /**
     * Participant's calculated role.              (Legal values:  DUO,  NONE,  SOLO,  DUO_CARRY,  DUO_SUPPORT)
     * @type {string}
     * @memberof MatchV4ParticipantTimelineDto
     */
    role?: MatchV4ParticipantTimelineDto.RoleEnum;
    /**
     * Damage taken difference versus the calculated lane opponent(s) for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    damageTakenDiffPerMinDeltas?: { [key: string]: number; };
    /**
     * Damage taken for a specified period.
     * @type {{ [key: string]: number; }}
     * @memberof MatchV4ParticipantTimelineDto
     */
    damageTakenPerMinDeltas?: { [key: string]: number; };
}

/**
 * @export
 * @namespace MatchV4ParticipantTimelineDto
 */
export namespace MatchV4ParticipantTimelineDto {
    /**
     * @export
     * @enum {string}
     */
    export enum LaneEnum {
        MID = <any> 'MID',
        MIDDLE = <any> 'MIDDLE',
        TOP = <any> 'TOP',
        JUNGLE = <any> 'JUNGLE',
        BOT = <any> 'BOT',
        BOTTOM = <any> 'BOTTOM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        DUO = <any> 'DUO',
        NONE = <any> 'NONE',
        SOLO = <any> 'SOLO',
        DUOCARRY = <any> 'DUO_CARRY',
        DUOSUPPORT = <any> 'DUO_SUPPORT'
    }
}

/**
 * 
 * @export
 * @interface MatchV4PlayerDto
 */
export interface MatchV4PlayerDto {
    /**
     * 
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    currentPlatformId?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    summonerName?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    matchHistoryUri?: string;
    /**
     * Original platformId.
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    platformId?: string;
    /**
     * Player's current accountId (Encrypted)
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    currentAccountId?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchV4PlayerDto
     */
    profileIcon?: number;
    /**
     * Player's summonerId (Encrypted)
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    summonerId?: string;
    /**
     * Player's original accountId (Encrypted)
     * @type {string}
     * @memberof MatchV4PlayerDto
     */
    accountId?: string;
}

/**
 * 
 * @export
 * @interface MatchV4RuneDto
 */
export interface MatchV4RuneDto {
    /**
     * 
     * @type {number}
     * @memberof MatchV4RuneDto
     */
    runeId?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchV4RuneDto
     */
    rank?: number;
}

/**
 * 
 * @export
 * @interface MatchV4TeamBansDto
 */
export interface MatchV4TeamBansDto {
    /**
     * Turn during which the champion was banned.
     * @type {number}
     * @memberof MatchV4TeamBansDto
     */
    pickTurn?: number;
    /**
     * Banned championId.
     * @type {number}
     * @memberof MatchV4TeamBansDto
     */
    championId?: number;
}

/**
 * 
 * @export
 * @interface MatchV4TeamStatsDto
 */
export interface MatchV4TeamStatsDto {
    /**
     * Flag indicating whether or not the team scored the first Dragon kill.
     * @type {boolean}
     * @memberof MatchV4TeamStatsDto
     */
    firstDragon?: boolean;
    /**
     * Flag indicating whether or not the team destroyed the first inhibitor.
     * @type {boolean}
     * @memberof MatchV4TeamStatsDto
     */
    firstInhibitor?: boolean;
    /**
     * If match queueId has a draft, contains banned champion data, otherwise empty.
     * @type {Array<MatchV4TeamBansDto>}
     * @memberof MatchV4TeamStatsDto
     */
    bans?: Array<MatchV4TeamBansDto>;
    /**
     * Number of times the team killed Baron.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    baronKills?: number;
    /**
     * Flag indicating whether or not the team scored the first Rift Herald kill.
     * @type {boolean}
     * @memberof MatchV4TeamStatsDto
     */
    firstRiftHerald?: boolean;
    /**
     * Flag indicating whether or not the team scored the first Baron kill.
     * @type {boolean}
     * @memberof MatchV4TeamStatsDto
     */
    firstBaron?: boolean;
    /**
     * Number of times the team killed Rift Herald.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    riftHeraldKills?: number;
    /**
     * Flag indicating whether or not the team scored the first blood.
     * @type {boolean}
     * @memberof MatchV4TeamStatsDto
     */
    firstBlood?: boolean;
    /**
     * 100 for blue side. 200 for red side.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    teamId?: number;
    /**
     * Flag indicating whether or not the team destroyed the first tower.
     * @type {boolean}
     * @memberof MatchV4TeamStatsDto
     */
    firstTower?: boolean;
    /**
     * Number of times the team killed Vilemaw.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    vilemawKills?: number;
    /**
     * Number of inhibitors the team destroyed.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    inhibitorKills?: number;
    /**
     * Number of towers the team destroyed.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    towerKills?: number;
    /**
     * For Dominion matches, specifies the points the team had at game end.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    dominionVictoryScore?: number;
    /**
     * String indicating whether or not the team won. There are only two values visibile in public match history.              (Legal values:  Fail,  Win)
     * @type {string}
     * @memberof MatchV4TeamStatsDto
     */
    win?: MatchV4TeamStatsDto.WinEnum;
    /**
     * Number of times the team killed Dragon.
     * @type {number}
     * @memberof MatchV4TeamStatsDto
     */
    dragonKills?: number;
}

/**
 * @export
 * @namespace MatchV4TeamStatsDto
 */
export namespace MatchV4TeamStatsDto {
    /**
     * @export
     * @enum {string}
     */
    export enum WinEnum {
        Fail = <any> 'Fail',
        Win = <any> 'Win'
    }
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {ErrorStatus}
     * @memberof ModelError
     */
    status?: ErrorStatus;
}

/**
 * 
 * @export
 * @interface SpectatorV4BannedChampion
 */
export interface SpectatorV4BannedChampion {
    /**
     * The turn during which the champion was banned
     * @type {number}
     * @memberof SpectatorV4BannedChampion
     */
    pickTurn?: number;
    /**
     * The ID of the banned champion
     * @type {number}
     * @memberof SpectatorV4BannedChampion
     */
    championId?: number;
    /**
     * The ID of the team that banned the champion
     * @type {number}
     * @memberof SpectatorV4BannedChampion
     */
    teamId?: number;
}

/**
 * 
 * @export
 * @interface SpectatorV4CurrentGameInfo
 */
export interface SpectatorV4CurrentGameInfo {
    /**
     * The ID of the game
     * @type {number}
     * @memberof SpectatorV4CurrentGameInfo
     */
    gameId?: number;
    /**
     * The game start time represented in epoch milliseconds
     * @type {number}
     * @memberof SpectatorV4CurrentGameInfo
     */
    gameStartTime?: number;
    /**
     * The ID of the platform on which the game is being played
     * @type {string}
     * @memberof SpectatorV4CurrentGameInfo
     */
    platformId?: string;
    /**
     * The game mode
     * @type {string}
     * @memberof SpectatorV4CurrentGameInfo
     */
    gameMode?: string;
    /**
     * The ID of the map
     * @type {number}
     * @memberof SpectatorV4CurrentGameInfo
     */
    mapId?: number;
    /**
     * The game type
     * @type {string}
     * @memberof SpectatorV4CurrentGameInfo
     */
    gameType?: string;
    /**
     * Banned champion information
     * @type {Array<SpectatorV4BannedChampion>}
     * @memberof SpectatorV4CurrentGameInfo
     */
    bannedChampions?: Array<SpectatorV4BannedChampion>;
    /**
     * The observer information
     * @type {SpectatorV4Observer}
     * @memberof SpectatorV4CurrentGameInfo
     */
    observers?: SpectatorV4Observer;
    /**
     * The participant information
     * @type {Array<SpectatorV4CurrentGameParticipant>}
     * @memberof SpectatorV4CurrentGameInfo
     */
    participants?: Array<SpectatorV4CurrentGameParticipant>;
    /**
     * The amount of time in seconds that has passed since the game started
     * @type {number}
     * @memberof SpectatorV4CurrentGameInfo
     */
    gameLength?: number;
    /**
     * The queue type (queue types are documented on the Game Constants page)
     * @type {number}
     * @memberof SpectatorV4CurrentGameInfo
     */
    gameQueueConfigId?: number;
}

/**
 * 
 * @export
 * @interface SpectatorV4CurrentGameParticipant
 */
export interface SpectatorV4CurrentGameParticipant {
    /**
     * The ID of the profile icon used by this participant
     * @type {number}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    profileIconId?: number;
    /**
     * The ID of the champion played by this participant
     * @type {number}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    championId?: number;
    /**
     * The summoner name of this participant
     * @type {string}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    summonerName?: string;
    /**
     * List of Game Customizations
     * @type {Array<SpectatorV4GameCustomizationObject>}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    gameCustomizationObjects?: Array<SpectatorV4GameCustomizationObject>;
    /**
     * Flag indicating whether or not this participant is a bot
     * @type {boolean}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    bot?: boolean;
    /**
     * Perks/Runes Reforged Information
     * @type {SpectatorV4Perks}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    perks?: SpectatorV4Perks;
    /**
     * The ID of the second summoner spell used by this participant
     * @type {number}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    spell2Id?: number;
    /**
     * The team ID of this participant, indicating the participant's team
     * @type {number}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    teamId?: number;
    /**
     * The ID of the first summoner spell used by this participant
     * @type {number}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    spell1Id?: number;
    /**
     * The encrypted summoner ID of this participant
     * @type {string}
     * @memberof SpectatorV4CurrentGameParticipant
     */
    summonerId?: string;
}

/**
 * 
 * @export
 * @interface SpectatorV4FeaturedGameInfo
 */
export interface SpectatorV4FeaturedGameInfo {
    /**
     * The ID of the game
     * @type {number}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    gameId?: number;
    /**
     * The game start time represented in epoch milliseconds
     * @type {number}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    gameStartTime?: number;
    /**
     * The ID of the platform on which the game is being played
     * @type {string}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    platformId?: string;
    /**
     * The game mode              (Legal values:  CLASSIC,  ODIN,  ARAM,  TUTORIAL,  ONEFORALL,  ASCENSION,  FIRSTBLOOD,  KINGPORO)
     * @type {string}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    gameMode?: SpectatorV4FeaturedGameInfo.GameModeEnum;
    /**
     * The ID of the map
     * @type {number}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    mapId?: number;
    /**
     * The game type              (Legal values:  CUSTOM_GAME,  MATCHED_GAME,  TUTORIAL_GAME)
     * @type {string}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    gameType?: SpectatorV4FeaturedGameInfo.GameTypeEnum;
    /**
     * Banned champion information
     * @type {Array<SpectatorV4BannedChampion>}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    bannedChampions?: Array<SpectatorV4BannedChampion>;
    /**
     * The observer information
     * @type {SpectatorV4Observer}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    observers?: SpectatorV4Observer;
    /**
     * The participant information
     * @type {Array<SpectatorV4Participant>}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    participants?: Array<SpectatorV4Participant>;
    /**
     * The amount of time in seconds that has passed since the game started
     * @type {number}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    gameLength?: number;
    /**
     * The queue type (queue types are documented on the Game Constants page)
     * @type {number}
     * @memberof SpectatorV4FeaturedGameInfo
     */
    gameQueueConfigId?: number;
}

/**
 * @export
 * @namespace SpectatorV4FeaturedGameInfo
 */
export namespace SpectatorV4FeaturedGameInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum GameModeEnum {
        CLASSIC = <any> 'CLASSIC',
        ODIN = <any> 'ODIN',
        ARAM = <any> 'ARAM',
        TUTORIAL = <any> 'TUTORIAL',
        ONEFORALL = <any> 'ONEFORALL',
        ASCENSION = <any> 'ASCENSION',
        FIRSTBLOOD = <any> 'FIRSTBLOOD',
        KINGPORO = <any> 'KINGPORO'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GameTypeEnum {
        CUSTOMGAME = <any> 'CUSTOM_GAME',
        MATCHEDGAME = <any> 'MATCHED_GAME',
        TUTORIALGAME = <any> 'TUTORIAL_GAME'
    }
}

/**
 * 
 * @export
 * @interface SpectatorV4FeaturedGames
 */
export interface SpectatorV4FeaturedGames {
    /**
     * The suggested interval to wait before requesting FeaturedGames again
     * @type {number}
     * @memberof SpectatorV4FeaturedGames
     */
    clientRefreshInterval?: number;
    /**
     * The list of featured games
     * @type {Array<SpectatorV4FeaturedGameInfo>}
     * @memberof SpectatorV4FeaturedGames
     */
    gameList?: Array<SpectatorV4FeaturedGameInfo>;
}

/**
 * 
 * @export
 * @interface SpectatorV4GameCustomizationObject
 */
export interface SpectatorV4GameCustomizationObject {
    /**
     * Category identifier for Game Customization
     * @type {string}
     * @memberof SpectatorV4GameCustomizationObject
     */
    category?: string;
    /**
     * Game Customization content
     * @type {string}
     * @memberof SpectatorV4GameCustomizationObject
     */
    content?: string;
}

/**
 * 
 * @export
 * @interface SpectatorV4Observer
 */
export interface SpectatorV4Observer {
    /**
     * Key used to decrypt the spectator grid game data for playback
     * @type {string}
     * @memberof SpectatorV4Observer
     */
    encryptionKey?: string;
}

/**
 * 
 * @export
 * @interface SpectatorV4Participant
 */
export interface SpectatorV4Participant {
    /**
     * The ID of the profile icon used by this participant
     * @type {number}
     * @memberof SpectatorV4Participant
     */
    profileIconId?: number;
    /**
     * The ID of the champion played by this participant
     * @type {number}
     * @memberof SpectatorV4Participant
     */
    championId?: number;
    /**
     * The summoner name of this participant
     * @type {string}
     * @memberof SpectatorV4Participant
     */
    summonerName?: string;
    /**
     * Flag indicating whether or not this participant is a bot
     * @type {boolean}
     * @memberof SpectatorV4Participant
     */
    bot?: boolean;
    /**
     * The ID of the second summoner spell used by this participant
     * @type {number}
     * @memberof SpectatorV4Participant
     */
    spell2Id?: number;
    /**
     * The team ID of this participant, indicating the participant's team
     * @type {number}
     * @memberof SpectatorV4Participant
     */
    teamId?: number;
    /**
     * The ID of the first summoner spell used by this participant
     * @type {number}
     * @memberof SpectatorV4Participant
     */
    spell1Id?: number;
}

/**
 * 
 * @export
 * @interface SpectatorV4Perks
 */
export interface SpectatorV4Perks {
    /**
     * Primary runes path
     * @type {number}
     * @memberof SpectatorV4Perks
     */
    perkStyle?: number;
    /**
     * IDs of the perks/runes assigned.
     * @type {Array<number>}
     * @memberof SpectatorV4Perks
     */
    perkIds?: Array<number>;
    /**
     * Secondary runes path
     * @type {number}
     * @memberof SpectatorV4Perks
     */
    perkSubStyle?: number;
}

/**
 * represents a summoner
 * @export
 * @interface SummonerV4SummonerDTO
 */
export interface SummonerV4SummonerDTO {
    /**
     * ID of the summoner icon associated with the summoner.
     * @type {number}
     * @memberof SummonerV4SummonerDTO
     */
    profileIconId?: number;
    /**
     * Summoner name.
     * @type {string}
     * @memberof SummonerV4SummonerDTO
     */
    name?: string;
    /**
     * Encrypted PUUID. Exact length of 78 characters.
     * @type {string}
     * @memberof SummonerV4SummonerDTO
     */
    puuid?: string;
    /**
     * Summoner level associated with the summoner.
     * @type {number}
     * @memberof SummonerV4SummonerDTO
     */
    summonerLevel?: number;
    /**
     * Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: profile icon change, playing the tutorial or advanced tutorial, finishing a game, summoner name change
     * @type {number}
     * @memberof SummonerV4SummonerDTO
     */
    revisionDate?: number;
    /**
     * Encrypted summoner ID. Max length 63 characters.
     * @type {string}
     * @memberof SummonerV4SummonerDTO
     */
    id?: string;
    /**
     * Encrypted account ID. Max length 56 characters.
     * @type {string}
     * @memberof SummonerV4SummonerDTO
     */
    accountId?: string;
}

/**
 * 
 * @export
 * @interface TournamentStubV4LobbyEventDTO
 */
export interface TournamentStubV4LobbyEventDTO {
    /**
     * The type of event that was triggered
     * @type {string}
     * @memberof TournamentStubV4LobbyEventDTO
     */
    eventType?: string;
    /**
     * The summonerId that triggered the event (Encrypted)
     * @type {string}
     * @memberof TournamentStubV4LobbyEventDTO
     */
    summonerId?: string;
    /**
     * Timestamp from the event
     * @type {string}
     * @memberof TournamentStubV4LobbyEventDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 * @interface TournamentStubV4LobbyEventDTOWrapper
 */
export interface TournamentStubV4LobbyEventDTOWrapper {
    /**
     * 
     * @type {Array<TournamentStubV4LobbyEventDTO>}
     * @memberof TournamentStubV4LobbyEventDTOWrapper
     */
    eventList?: Array<TournamentStubV4LobbyEventDTO>;
}

/**
 * 
 * @export
 * @interface TournamentStubV4ProviderRegistrationParameters
 */
export interface TournamentStubV4ProviderRegistrationParameters {
    /**
     * The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443).
     * @type {string}
     * @memberof TournamentStubV4ProviderRegistrationParameters
     */
    url: string;
    /**
     * The region in which the provider will be running tournaments.              (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR)
     * @type {string}
     * @memberof TournamentStubV4ProviderRegistrationParameters
     */
    region: TournamentStubV4ProviderRegistrationParameters.RegionEnum;
}

/**
 * @export
 * @namespace TournamentStubV4ProviderRegistrationParameters
 */
export namespace TournamentStubV4ProviderRegistrationParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        BR = <any> 'BR',
        EUNE = <any> 'EUNE',
        EUW = <any> 'EUW',
        JP = <any> 'JP',
        LAN = <any> 'LAN',
        LAS = <any> 'LAS',
        NA = <any> 'NA',
        OCE = <any> 'OCE',
        PBE = <any> 'PBE',
        RU = <any> 'RU',
        TR = <any> 'TR'
    }
}

/**
 * 
 * @export
 * @interface TournamentStubV4TournamentCodeParameters
 */
export interface TournamentStubV4TournamentCodeParameters {
    /**
     * The spectator type of the game.              (Legal values:  NONE,  LOBBYONLY,  ALL)
     * @type {string}
     * @memberof TournamentStubV4TournamentCodeParameters
     */
    spectatorType: TournamentStubV4TournamentCodeParameters.SpectatorTypeEnum;
    /**
     * The team size of the game. Valid values are 1-5.
     * @type {number}
     * @memberof TournamentStubV4TournamentCodeParameters
     */
    teamSize: number;
    /**
     * The pick type of the game.              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
     * @type {string}
     * @memberof TournamentStubV4TournamentCodeParameters
     */
    pickType: TournamentStubV4TournamentCodeParameters.PickTypeEnum;
    /**
     * Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
     * @type {Array<string>}
     * @memberof TournamentStubV4TournamentCodeParameters
     */
    allowedSummonerIds?: Array<string>;
    /**
     * The map type of the game.              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
     * @type {string}
     * @memberof TournamentStubV4TournamentCodeParameters
     */
    mapType: TournamentStubV4TournamentCodeParameters.MapTypeEnum;
    /**
     * Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game.
     * @type {string}
     * @memberof TournamentStubV4TournamentCodeParameters
     */
    metadata?: string;
}

/**
 * @export
 * @namespace TournamentStubV4TournamentCodeParameters
 */
export namespace TournamentStubV4TournamentCodeParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum SpectatorTypeEnum {
        NONE = <any> 'NONE',
        LOBBYONLY = <any> 'LOBBYONLY',
        ALL = <any> 'ALL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PickTypeEnum {
        BLINDPICK = <any> 'BLIND_PICK',
        DRAFTMODE = <any> 'DRAFT_MODE',
        ALLRANDOM = <any> 'ALL_RANDOM',
        TOURNAMENTDRAFT = <any> 'TOURNAMENT_DRAFT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MapTypeEnum {
        SUMMONERSRIFT = <any> 'SUMMONERS_RIFT',
        TWISTEDTREELINE = <any> 'TWISTED_TREELINE',
        HOWLINGABYSS = <any> 'HOWLING_ABYSS'
    }
}

/**
 * 
 * @export
 * @interface TournamentStubV4TournamentRegistrationParameters
 */
export interface TournamentStubV4TournamentRegistrationParameters {
    /**
     * The provider ID to specify the regional registered provider data to associate this tournament.
     * @type {number}
     * @memberof TournamentStubV4TournamentRegistrationParameters
     */
    providerId: number;
    /**
     * The optional name of the tournament.
     * @type {string}
     * @memberof TournamentStubV4TournamentRegistrationParameters
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface TournamentV4LobbyEventDTO
 */
export interface TournamentV4LobbyEventDTO {
    /**
     * Timestamp from the event
     * @type {string}
     * @memberof TournamentV4LobbyEventDTO
     */
    timestamp?: string;
    /**
     * The summonerId that triggered the event (Encrypted)
     * @type {string}
     * @memberof TournamentV4LobbyEventDTO
     */
    summonerId?: string;
    /**
     * The type of event that was triggered
     * @type {string}
     * @memberof TournamentV4LobbyEventDTO
     */
    eventType?: string;
}

/**
 * 
 * @export
 * @interface TournamentV4LobbyEventDTOWrapper
 */
export interface TournamentV4LobbyEventDTOWrapper {
    /**
     * 
     * @type {Array<TournamentV4LobbyEventDTO>}
     * @memberof TournamentV4LobbyEventDTOWrapper
     */
    eventList?: Array<TournamentV4LobbyEventDTO>;
}

/**
 * 
 * @export
 * @interface TournamentV4ProviderRegistrationParameters
 */
export interface TournamentV4ProviderRegistrationParameters {
    /**
     * The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443).
     * @type {string}
     * @memberof TournamentV4ProviderRegistrationParameters
     */
    url: string;
    /**
     * The region in which the provider will be running tournaments.              (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR)
     * @type {string}
     * @memberof TournamentV4ProviderRegistrationParameters
     */
    region: TournamentV4ProviderRegistrationParameters.RegionEnum;
}

/**
 * @export
 * @namespace TournamentV4ProviderRegistrationParameters
 */
export namespace TournamentV4ProviderRegistrationParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        BR = <any> 'BR',
        EUNE = <any> 'EUNE',
        EUW = <any> 'EUW',
        JP = <any> 'JP',
        LAN = <any> 'LAN',
        LAS = <any> 'LAS',
        NA = <any> 'NA',
        OCE = <any> 'OCE',
        PBE = <any> 'PBE',
        RU = <any> 'RU',
        TR = <any> 'TR'
    }
}

/**
 * 
 * @export
 * @interface TournamentV4TournamentCodeDTO
 */
export interface TournamentV4TournamentCodeDTO {
    /**
     * The game map for the tournament code game
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    map?: string;
    /**
     * The tournament code.
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    code?: string;
    /**
     * The spectator mode for the tournament code game.
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    spectators?: string;
    /**
     * The tournament code's region.              (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR)
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    region?: TournamentV4TournamentCodeDTO.RegionEnum;
    /**
     * The provider's ID.
     * @type {number}
     * @memberof TournamentV4TournamentCodeDTO
     */
    providerId?: number;
    /**
     * The team size for the tournament code game.
     * @type {number}
     * @memberof TournamentV4TournamentCodeDTO
     */
    teamSize?: number;
    /**
     * The summonerIds of the participants (Encrypted)
     * @type {Array<string>}
     * @memberof TournamentV4TournamentCodeDTO
     */
    participants?: Array<string>;
    /**
     * The pick mode for tournament code game.
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    pickType?: string;
    /**
     * The tournament's ID.
     * @type {number}
     * @memberof TournamentV4TournamentCodeDTO
     */
    tournamentId?: number;
    /**
     * The lobby name for the tournament code game.
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    lobbyName?: string;
    /**
     * The password for the tournament code game.
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    password?: string;
    /**
     * The tournament code's ID.
     * @type {number}
     * @memberof TournamentV4TournamentCodeDTO
     */
    id?: number;
    /**
     * The metadata for tournament code.
     * @type {string}
     * @memberof TournamentV4TournamentCodeDTO
     */
    metaData?: string;
}

/**
 * @export
 * @namespace TournamentV4TournamentCodeDTO
 */
export namespace TournamentV4TournamentCodeDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        BR = <any> 'BR',
        EUNE = <any> 'EUNE',
        EUW = <any> 'EUW',
        JP = <any> 'JP',
        LAN = <any> 'LAN',
        LAS = <any> 'LAS',
        NA = <any> 'NA',
        OCE = <any> 'OCE',
        PBE = <any> 'PBE',
        RU = <any> 'RU',
        TR = <any> 'TR'
    }
}

/**
 * 
 * @export
 * @interface TournamentV4TournamentCodeParameters
 */
export interface TournamentV4TournamentCodeParameters {
    /**
     * The spectator type of the game.              (Legal values:  NONE,  LOBBYONLY,  ALL)
     * @type {string}
     * @memberof TournamentV4TournamentCodeParameters
     */
    spectatorType: TournamentV4TournamentCodeParameters.SpectatorTypeEnum;
    /**
     * The team size of the game. Valid values are 1-5.
     * @type {number}
     * @memberof TournamentV4TournamentCodeParameters
     */
    teamSize: number;
    /**
     * The pick type of the game.              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
     * @type {string}
     * @memberof TournamentV4TournamentCodeParameters
     */
    pickType: TournamentV4TournamentCodeParameters.PickTypeEnum;
    /**
     * Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
     * @type {Array<string>}
     * @memberof TournamentV4TournamentCodeParameters
     */
    allowedSummonerIds?: Array<string>;
    /**
     * The map type of the game.              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
     * @type {string}
     * @memberof TournamentV4TournamentCodeParameters
     */
    mapType: TournamentV4TournamentCodeParameters.MapTypeEnum;
    /**
     * Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game.
     * @type {string}
     * @memberof TournamentV4TournamentCodeParameters
     */
    metadata?: string;
}

/**
 * @export
 * @namespace TournamentV4TournamentCodeParameters
 */
export namespace TournamentV4TournamentCodeParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum SpectatorTypeEnum {
        NONE = <any> 'NONE',
        LOBBYONLY = <any> 'LOBBYONLY',
        ALL = <any> 'ALL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PickTypeEnum {
        BLINDPICK = <any> 'BLIND_PICK',
        DRAFTMODE = <any> 'DRAFT_MODE',
        ALLRANDOM = <any> 'ALL_RANDOM',
        TOURNAMENTDRAFT = <any> 'TOURNAMENT_DRAFT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MapTypeEnum {
        SUMMONERSRIFT = <any> 'SUMMONERS_RIFT',
        TWISTEDTREELINE = <any> 'TWISTED_TREELINE',
        HOWLINGABYSS = <any> 'HOWLING_ABYSS'
    }
}

/**
 * 
 * @export
 * @interface TournamentV4TournamentCodeUpdateParameters
 */
export interface TournamentV4TournamentCodeUpdateParameters {
    /**
     * The spectator type              (Legal values:  NONE,  LOBBYONLY,  ALL)
     * @type {string}
     * @memberof TournamentV4TournamentCodeUpdateParameters
     */
    spectatorType: TournamentV4TournamentCodeUpdateParameters.SpectatorTypeEnum;
    /**
     * The pick type              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
     * @type {string}
     * @memberof TournamentV4TournamentCodeUpdateParameters
     */
    pickType: TournamentV4TournamentCodeUpdateParameters.PickTypeEnum;
    /**
     * Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
     * @type {Array<string>}
     * @memberof TournamentV4TournamentCodeUpdateParameters
     */
    allowedSummonerIds?: Array<string>;
    /**
     * The map type              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
     * @type {string}
     * @memberof TournamentV4TournamentCodeUpdateParameters
     */
    mapType: TournamentV4TournamentCodeUpdateParameters.MapTypeEnum;
}

/**
 * @export
 * @namespace TournamentV4TournamentCodeUpdateParameters
 */
export namespace TournamentV4TournamentCodeUpdateParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum SpectatorTypeEnum {
        NONE = <any> 'NONE',
        LOBBYONLY = <any> 'LOBBYONLY',
        ALL = <any> 'ALL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PickTypeEnum {
        BLINDPICK = <any> 'BLIND_PICK',
        DRAFTMODE = <any> 'DRAFT_MODE',
        ALLRANDOM = <any> 'ALL_RANDOM',
        TOURNAMENTDRAFT = <any> 'TOURNAMENT_DRAFT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MapTypeEnum {
        SUMMONERSRIFT = <any> 'SUMMONERS_RIFT',
        TWISTEDTREELINE = <any> 'TWISTED_TREELINE',
        HOWLINGABYSS = <any> 'HOWLING_ABYSS'
    }
}

/**
 * 
 * @export
 * @interface TournamentV4TournamentRegistrationParameters
 */
export interface TournamentV4TournamentRegistrationParameters {
    /**
     * The provider ID to specify the regional registered provider data to associate this tournament.
     * @type {number}
     * @memberof TournamentV4TournamentRegistrationParameters
     */
    providerId: number;
    /**
     * The optional name of the tournament.
     * @type {string}
     * @memberof TournamentV4TournamentRegistrationParameters
     */
    name?: string;
}


/**
 * ChampionMasteryV4Api - fetch parameter creator
 * @export
 */
export const ChampionMasteryV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all champion mastery entries sorted by number of champion points descending,
         * @summary Get all champion mastery entries sorted by number of champion points descending,
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetAllChampionMasteries(encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling championMasteryV4GetAllChampionMasteries.');
            }
            const localVarPath = `/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}`
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a champion mastery by player ID and champion ID.
         * @summary Get a champion mastery by player ID and champion ID.
         * @param {number} championId Champion ID to retrieve Champion Mastery for
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetChampionMastery(championId: number, encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'championId' is not null or undefined
            if (championId === null || championId === undefined) {
                throw new RequiredError('championId','Required parameter championId was null or undefined when calling championMasteryV4GetChampionMastery.');
            }
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling championMasteryV4GetChampionMastery.');
            }
            const localVarPath = `/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}/by-champion/{championId}`
                .replace(`{${"championId"}}`, encodeURIComponent(String(championId)))
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
         * @summary Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetChampionMasteryScore(encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling championMasteryV4GetChampionMasteryScore.');
            }
            const localVarPath = `/lol/champion-mastery/v4/scores/by-summoner/{encryptedSummonerId}`
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChampionMasteryV4Api - functional programming interface
 * @export
 */
export const ChampionMasteryV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all champion mastery entries sorted by number of champion points descending,
         * @summary Get all champion mastery entries sorted by number of champion points descending,
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetAllChampionMasteries(encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChampionMasteryV4ChampionMasteryDTO>> {
            const localVarFetchArgs = ChampionMasteryV4ApiFetchParamCreator(configuration).championMasteryV4GetAllChampionMasteries(encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a champion mastery by player ID and champion ID.
         * @summary Get a champion mastery by player ID and champion ID.
         * @param {number} championId Champion ID to retrieve Champion Mastery for
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetChampionMastery(championId: number, encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChampionMasteryV4ChampionMasteryDTO> {
            const localVarFetchArgs = ChampionMasteryV4ApiFetchParamCreator(configuration).championMasteryV4GetChampionMastery(championId, encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
         * @summary Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetChampionMasteryScore(encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = ChampionMasteryV4ApiFetchParamCreator(configuration).championMasteryV4GetChampionMasteryScore(encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChampionMasteryV4Api - factory interface
 * @export
 */
export const ChampionMasteryV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all champion mastery entries sorted by number of champion points descending,
         * @summary Get all champion mastery entries sorted by number of champion points descending,
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetAllChampionMasteries(encryptedSummonerId: string, options?: any) {
            return ChampionMasteryV4ApiFp(configuration).championMasteryV4GetAllChampionMasteries(encryptedSummonerId, options)(fetch, basePath);
        },
        /**
         * Get a champion mastery by player ID and champion ID.
         * @summary Get a champion mastery by player ID and champion ID.
         * @param {number} championId Champion ID to retrieve Champion Mastery for
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetChampionMastery(championId: number, encryptedSummonerId: string, options?: any) {
            return ChampionMasteryV4ApiFp(configuration).championMasteryV4GetChampionMastery(championId, encryptedSummonerId, options)(fetch, basePath);
        },
        /**
         * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
         * @summary Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
         * @param {string} encryptedSummonerId Summoner ID associated with the player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championMasteryV4GetChampionMasteryScore(encryptedSummonerId: string, options?: any) {
            return ChampionMasteryV4ApiFp(configuration).championMasteryV4GetChampionMasteryScore(encryptedSummonerId, options)(fetch, basePath);
        },
    };
};

/**
 * ChampionMasteryV4Api - object-oriented interface
 * @export
 * @class ChampionMasteryV4Api
 * @extends {BaseAPI}
 */
export class ChampionMasteryV4Api extends BaseAPI {
    /**
     * Get all champion mastery entries sorted by number of champion points descending,
     * @summary Get all champion mastery entries sorted by number of champion points descending,
     * @param {string} encryptedSummonerId Summoner ID associated with the player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionMasteryV4Api
     */
    public championMasteryV4GetAllChampionMasteries(encryptedSummonerId: string, options?: any) {
        return ChampionMasteryV4ApiFp(this.configuration).championMasteryV4GetAllChampionMasteries(encryptedSummonerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a champion mastery by player ID and champion ID.
     * @summary Get a champion mastery by player ID and champion ID.
     * @param {number} championId Champion ID to retrieve Champion Mastery for
     * @param {string} encryptedSummonerId Summoner ID associated with the player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionMasteryV4Api
     */
    public championMasteryV4GetChampionMastery(championId: number, encryptedSummonerId: string, options?: any) {
        return ChampionMasteryV4ApiFp(this.configuration).championMasteryV4GetChampionMastery(championId, encryptedSummonerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
     * @summary Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
     * @param {string} encryptedSummonerId Summoner ID associated with the player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionMasteryV4Api
     */
    public championMasteryV4GetChampionMasteryScore(encryptedSummonerId: string, options?: any) {
        return ChampionMasteryV4ApiFp(this.configuration).championMasteryV4GetChampionMasteryScore(encryptedSummonerId, options)(this.fetch, this.basePath);
    }

}

/**
 * ChampionV3Api - fetch parameter creator
 * @export
 */
export const ChampionV3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
         * @summary Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championV3GetChampionInfo(options: any = {}): FetchArgs {
            const localVarPath = `/lol/platform/v3/champion-rotations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChampionV3Api - functional programming interface
 * @export
 */
export const ChampionV3ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
         * @summary Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championV3GetChampionInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChampionV3ChampionInfo> {
            const localVarFetchArgs = ChampionV3ApiFetchParamCreator(configuration).championV3GetChampionInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChampionV3Api - factory interface
 * @export
 */
export const ChampionV3ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
         * @summary Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        championV3GetChampionInfo(options?: any) {
            return ChampionV3ApiFp(configuration).championV3GetChampionInfo(options)(fetch, basePath);
        },
    };
};

/**
 * ChampionV3Api - object-oriented interface
 * @export
 * @class ChampionV3Api
 * @extends {BaseAPI}
 */
export class ChampionV3Api extends BaseAPI {
    /**
     * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
     * @summary Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionV3Api
     */
    public championV3GetChampionInfo(options?: any) {
        return ChampionV3ApiFp(this.configuration).championV3GetChampionInfo(options)(this.fetch, this.basePath);
    }

}

/**
 * LeagueV4Api - fetch parameter creator
 * @export
 */
export const LeagueV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the challenger league for given queue.
         * @summary Get the challenger league for given queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetChallengerLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling leagueV4GetChallengerLeague.');
            }
            const localVarPath = `/lol/league/v4/challengerleagues/by-queue/{queue}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the grandmaster league of a specific queue.
         * @summary Get the grandmaster league of a specific queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetGrandmasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling leagueV4GetGrandmasterLeague.');
            }
            const localVarPath = `/lol/league/v4/grandmasterleagues/by-queue/{queue}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get league with given ID, including inactive entries.
         * @summary Get league with given ID, including inactive entries.
         * @param {string} leagueId The UUID of the league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueById(leagueId: string, options: any = {}): FetchArgs {
            // verify required parameter 'leagueId' is not null or undefined
            if (leagueId === null || leagueId === undefined) {
                throw new RequiredError('leagueId','Required parameter leagueId was null or undefined when calling leagueV4GetLeagueById.');
            }
            const localVarPath = `/lol/league/v4/leagues/{leagueId}`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the league entries.
         * @summary Get all the league entries.
         * @param {'I' | 'II' | 'III' | 'IV'} division 
         * @param {'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON'} tier 
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue Note that the queue value must be a valid ranked queue.
         * @param {number} [page] Starts with page 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueEntries(division: 'I' | 'II' | 'III' | 'IV', tier: 'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON', queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'division' is not null or undefined
            if (division === null || division === undefined) {
                throw new RequiredError('division','Required parameter division was null or undefined when calling leagueV4GetLeagueEntries.');
            }
            // verify required parameter 'tier' is not null or undefined
            if (tier === null || tier === undefined) {
                throw new RequiredError('tier','Required parameter tier was null or undefined when calling leagueV4GetLeagueEntries.');
            }
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling leagueV4GetLeagueEntries.');
            }
            const localVarPath = `/lol/league/v4/entries/{queue}/{tier}/{division}`
                .replace(`{${"division"}}`, encodeURIComponent(String(division)))
                .replace(`{${"tier"}}`, encodeURIComponent(String(tier)))
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get league entries in all queues for a given summoner ID.
         * @summary Get league entries in all queues for a given summoner ID.
         * @param {string} encryptedSummonerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling leagueV4GetLeagueEntriesForSummoner.');
            }
            const localVarPath = `/lol/league/v4/entries/by-summoner/{encryptedSummonerId}`
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the master league for given queue.
         * @summary Get the master league for given queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetMasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling leagueV4GetMasterLeague.');
            }
            const localVarPath = `/lol/league/v4/masterleagues/by-queue/{queue}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeagueV4Api - functional programming interface
 * @export
 */
export const LeagueV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the challenger league for given queue.
         * @summary Get the challenger league for given queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetChallengerLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeagueV4LeagueListDTO> {
            const localVarFetchArgs = LeagueV4ApiFetchParamCreator(configuration).leagueV4GetChallengerLeague(queue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the grandmaster league of a specific queue.
         * @summary Get the grandmaster league of a specific queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetGrandmasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeagueV4LeagueListDTO> {
            const localVarFetchArgs = LeagueV4ApiFetchParamCreator(configuration).leagueV4GetGrandmasterLeague(queue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get league with given ID, including inactive entries.
         * @summary Get league with given ID, including inactive entries.
         * @param {string} leagueId The UUID of the league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueById(leagueId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeagueV4LeagueListDTO> {
            const localVarFetchArgs = LeagueV4ApiFetchParamCreator(configuration).leagueV4GetLeagueById(leagueId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all the league entries.
         * @summary Get all the league entries.
         * @param {'I' | 'II' | 'III' | 'IV'} division 
         * @param {'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON'} tier 
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue Note that the queue value must be a valid ranked queue.
         * @param {number} [page] Starts with page 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueEntries(division: 'I' | 'II' | 'III' | 'IV', tier: 'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON', queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeagueV4LeagueEntryDTO>> {
            const localVarFetchArgs = LeagueV4ApiFetchParamCreator(configuration).leagueV4GetLeagueEntries(division, tier, queue, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get league entries in all queues for a given summoner ID.
         * @summary Get league entries in all queues for a given summoner ID.
         * @param {string} encryptedSummonerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeagueV4LeagueEntryDTO>> {
            const localVarFetchArgs = LeagueV4ApiFetchParamCreator(configuration).leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the master league for given queue.
         * @summary Get the master league for given queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetMasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeagueV4LeagueListDTO> {
            const localVarFetchArgs = LeagueV4ApiFetchParamCreator(configuration).leagueV4GetMasterLeague(queue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeagueV4Api - factory interface
 * @export
 */
export const LeagueV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the challenger league for given queue.
         * @summary Get the challenger league for given queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetChallengerLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any) {
            return LeagueV4ApiFp(configuration).leagueV4GetChallengerLeague(queue, options)(fetch, basePath);
        },
        /**
         * Get the grandmaster league of a specific queue.
         * @summary Get the grandmaster league of a specific queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetGrandmasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any) {
            return LeagueV4ApiFp(configuration).leagueV4GetGrandmasterLeague(queue, options)(fetch, basePath);
        },
        /**
         * Get league with given ID, including inactive entries.
         * @summary Get league with given ID, including inactive entries.
         * @param {string} leagueId The UUID of the league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueById(leagueId: string, options?: any) {
            return LeagueV4ApiFp(configuration).leagueV4GetLeagueById(leagueId, options)(fetch, basePath);
        },
        /**
         * Get all the league entries.
         * @summary Get all the league entries.
         * @param {'I' | 'II' | 'III' | 'IV'} division 
         * @param {'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON'} tier 
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue Note that the queue value must be a valid ranked queue.
         * @param {number} [page] Starts with page 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueEntries(division: 'I' | 'II' | 'III' | 'IV', tier: 'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON', queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', page?: number, options?: any) {
            return LeagueV4ApiFp(configuration).leagueV4GetLeagueEntries(division, tier, queue, page, options)(fetch, basePath);
        },
        /**
         * Get league entries in all queues for a given summoner ID.
         * @summary Get league entries in all queues for a given summoner ID.
         * @param {string} encryptedSummonerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId: string, options?: any) {
            return LeagueV4ApiFp(configuration).leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId, options)(fetch, basePath);
        },
        /**
         * Get the master league for given queue.
         * @summary Get the master league for given queue.
         * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueV4GetMasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any) {
            return LeagueV4ApiFp(configuration).leagueV4GetMasterLeague(queue, options)(fetch, basePath);
        },
    };
};

/**
 * LeagueV4Api - object-oriented interface
 * @export
 * @class LeagueV4Api
 * @extends {BaseAPI}
 */
export class LeagueV4Api extends BaseAPI {
    /**
     * Get the challenger league for given queue.
     * @summary Get the challenger league for given queue.
     * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeagueV4Api
     */
    public leagueV4GetChallengerLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any) {
        return LeagueV4ApiFp(this.configuration).leagueV4GetChallengerLeague(queue, options)(this.fetch, this.basePath);
    }

    /**
     * Get the grandmaster league of a specific queue.
     * @summary Get the grandmaster league of a specific queue.
     * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeagueV4Api
     */
    public leagueV4GetGrandmasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any) {
        return LeagueV4ApiFp(this.configuration).leagueV4GetGrandmasterLeague(queue, options)(this.fetch, this.basePath);
    }

    /**
     * Get league with given ID, including inactive entries.
     * @summary Get league with given ID, including inactive entries.
     * @param {string} leagueId The UUID of the league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeagueV4Api
     */
    public leagueV4GetLeagueById(leagueId: string, options?: any) {
        return LeagueV4ApiFp(this.configuration).leagueV4GetLeagueById(leagueId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all the league entries.
     * @summary Get all the league entries.
     * @param {'I' | 'II' | 'III' | 'IV'} division 
     * @param {'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON'} tier 
     * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue Note that the queue value must be a valid ranked queue.
     * @param {number} [page] Starts with page 1.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeagueV4Api
     */
    public leagueV4GetLeagueEntries(division: 'I' | 'II' | 'III' | 'IV', tier: 'DIAMOND' | 'PLATINUM' | 'GOLD' | 'SILVER' | 'BRONZE' | 'IRON', queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', page?: number, options?: any) {
        return LeagueV4ApiFp(this.configuration).leagueV4GetLeagueEntries(division, tier, queue, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get league entries in all queues for a given summoner ID.
     * @summary Get league entries in all queues for a given summoner ID.
     * @param {string} encryptedSummonerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeagueV4Api
     */
    public leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId: string, options?: any) {
        return LeagueV4ApiFp(this.configuration).leagueV4GetLeagueEntriesForSummoner(encryptedSummonerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get the master league for given queue.
     * @summary Get the master league for given queue.
     * @param {'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT'} queue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeagueV4Api
     */
    public leagueV4GetMasterLeague(queue: 'RANKED_SOLO_5x5' | 'RANKED_FLEX_SR' | 'RANKED_FLEX_TT', options?: any) {
        return LeagueV4ApiFp(this.configuration).leagueV4GetMasterLeague(queue, options)(this.fetch, this.basePath);
    }

}

/**
 * LolStatusV3Api - fetch parameter creator
 * @export
 */
export const LolStatusV3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get League of Legends status for the given shard. ## Rate Limit Notes Requests to this API are not counted against the application Rate Limits.
         * @summary Get League of Legends status for the given shard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lolStatusV3GetShardData(options: any = {}): FetchArgs {
            const localVarPath = `/lol/status/v3/shard-data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LolStatusV3Api - functional programming interface
 * @export
 */
export const LolStatusV3ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get League of Legends status for the given shard. ## Rate Limit Notes Requests to this API are not counted against the application Rate Limits.
         * @summary Get League of Legends status for the given shard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lolStatusV3GetShardData(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LolStatusV3ShardStatus> {
            const localVarFetchArgs = LolStatusV3ApiFetchParamCreator(configuration).lolStatusV3GetShardData(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LolStatusV3Api - factory interface
 * @export
 */
export const LolStatusV3ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get League of Legends status for the given shard. ## Rate Limit Notes Requests to this API are not counted against the application Rate Limits.
         * @summary Get League of Legends status for the given shard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lolStatusV3GetShardData(options?: any) {
            return LolStatusV3ApiFp(configuration).lolStatusV3GetShardData(options)(fetch, basePath);
        },
    };
};

/**
 * LolStatusV3Api - object-oriented interface
 * @export
 * @class LolStatusV3Api
 * @extends {BaseAPI}
 */
export class LolStatusV3Api extends BaseAPI {
    /**
     * Get League of Legends status for the given shard. ## Rate Limit Notes Requests to this API are not counted against the application Rate Limits.
     * @summary Get League of Legends status for the given shard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LolStatusV3Api
     */
    public lolStatusV3GetShardData(options?: any) {
        return LolStatusV3ApiFp(this.configuration).lolStatusV3GetShardData(options)(this.fetch, this.basePath);
    }

}

/**
 * MatchV4Api - fetch parameter creator
 * @export
 */
export const MatchV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get match by match ID.
         * @summary Get match by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatch(matchId: number, options: any = {}): FetchArgs {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling matchV4GetMatch.');
            }
            const localVarPath = `/lol/match/v4/matches/{matchId}`
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match by match ID and tournament code.
         * @summary Get match by match ID and tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentCode' is not null or undefined
            if (tournamentCode === null || tournamentCode === undefined) {
                throw new RequiredError('tournamentCode','Required parameter tournamentCode was null or undefined when calling matchV4GetMatchByTournamentCode.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling matchV4GetMatchByTournamentCode.');
            }
            const localVarPath = `/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match IDs by tournament code.
         * @summary Get match IDs by tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentCode' is not null or undefined
            if (tournamentCode === null || tournamentCode === undefined) {
                throw new RequiredError('tournamentCode','Required parameter tournamentCode was null or undefined when calling matchV4GetMatchIdsByTournamentCode.');
            }
            const localVarPath = `/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
         * @summary Get match timeline by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchTimeline(matchId: number, options: any = {}): FetchArgs {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling matchV4GetMatchTimeline.');
            }
            const localVarPath = `/lol/match/v4/timelines/by-match/{matchId}`
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
         * @param {string} encryptedAccountId The account ID.
         * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
         * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
         * @param {Array<number>} [season] Set of season IDs for filtering the matchlist.
         * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedAccountId' is not null or undefined
            if (encryptedAccountId === null || encryptedAccountId === undefined) {
                throw new RequiredError('encryptedAccountId','Required parameter encryptedAccountId was null or undefined when calling matchV4GetMatchlist.');
            }
            const localVarPath = `/lol/match/v4/matchlists/by-account/{encryptedAccountId}`
                .replace(`{${"encryptedAccountId"}}`, encodeURIComponent(String(encryptedAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (champion) {
                localVarQueryParameter['champion'] = champion.join(COLLECTION_FORMATS["csv"]);
            }

            if (queue) {
                localVarQueryParameter['queue'] = queue.join(COLLECTION_FORMATS["csv"]);
            }

            if (season) {
                localVarQueryParameter['season'] = season.join(COLLECTION_FORMATS["csv"]);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (beginTime !== undefined) {
                localVarQueryParameter['beginTime'] = beginTime;
            }

            if (endIndex !== undefined) {
                localVarQueryParameter['endIndex'] = endIndex;
            }

            if (beginIndex !== undefined) {
                localVarQueryParameter['beginIndex'] = beginIndex;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchV4Api - functional programming interface
 * @export
 */
export const MatchV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get match by match ID.
         * @summary Get match by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatch(matchId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MatchV4MatchDto> {
            const localVarFetchArgs = MatchV4ApiFetchParamCreator(configuration).matchV4GetMatch(matchId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get match by match ID and tournament code.
         * @summary Get match by match ID and tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MatchV4MatchDto> {
            const localVarFetchArgs = MatchV4ApiFetchParamCreator(configuration).matchV4GetMatchByTournamentCode(tournamentCode, matchId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get match IDs by tournament code.
         * @summary Get match IDs by tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = MatchV4ApiFetchParamCreator(configuration).matchV4GetMatchIdsByTournamentCode(tournamentCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
         * @summary Get match timeline by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchTimeline(matchId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MatchV4MatchTimelineDto> {
            const localVarFetchArgs = MatchV4ApiFetchParamCreator(configuration).matchV4GetMatchTimeline(matchId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
         * @param {string} encryptedAccountId The account ID.
         * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
         * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
         * @param {Array<number>} [season] Set of season IDs for filtering the matchlist.
         * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MatchV4MatchlistDto> {
            const localVarFetchArgs = MatchV4ApiFetchParamCreator(configuration).matchV4GetMatchlist(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MatchV4Api - factory interface
 * @export
 */
export const MatchV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get match by match ID.
         * @summary Get match by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatch(matchId: number, options?: any) {
            return MatchV4ApiFp(configuration).matchV4GetMatch(matchId, options)(fetch, basePath);
        },
        /**
         * Get match by match ID and tournament code.
         * @summary Get match by match ID and tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any) {
            return MatchV4ApiFp(configuration).matchV4GetMatchByTournamentCode(tournamentCode, matchId, options)(fetch, basePath);
        },
        /**
         * Get match IDs by tournament code.
         * @summary Get match IDs by tournament code.
         * @param {string} tournamentCode The tournament code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any) {
            return MatchV4ApiFp(configuration).matchV4GetMatchIdsByTournamentCode(tournamentCode, options)(fetch, basePath);
        },
        /**
         * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
         * @summary Get match timeline by match ID.
         * @param {number} matchId The match ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchTimeline(matchId: number, options?: any) {
            return MatchV4ApiFp(configuration).matchV4GetMatchTimeline(matchId, options)(fetch, basePath);
        },
        /**
         * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
         * @param {string} encryptedAccountId The account ID.
         * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
         * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
         * @param {Array<number>} [season] Set of season IDs for filtering the matchlist.
         * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
         * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any) {
            return MatchV4ApiFp(configuration).matchV4GetMatchlist(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, options)(fetch, basePath);
        },
    };
};

/**
 * MatchV4Api - object-oriented interface
 * @export
 * @class MatchV4Api
 * @extends {BaseAPI}
 */
export class MatchV4Api extends BaseAPI {
    /**
     * Get match by match ID.
     * @summary Get match by match ID.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatch(matchId: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatch(matchId, options)(this.fetch, this.basePath);
    }

    /**
     * Get match by match ID and tournament code.
     * @summary Get match by match ID and tournament code.
     * @param {string} tournamentCode The tournament code.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchByTournamentCode(tournamentCode: string, matchId: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchByTournamentCode(tournamentCode, matchId, options)(this.fetch, this.basePath);
    }

    /**
     * Get match IDs by tournament code.
     * @summary Get match IDs by tournament code.
     * @param {string} tournamentCode The tournament code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchIdsByTournamentCode(tournamentCode: string, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchIdsByTournamentCode(tournamentCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
     * @summary Get match timeline by match ID.
     * @param {number} matchId The match ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchTimeline(matchId: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchTimeline(matchId, options)(this.fetch, this.basePath);
    }

    /**
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @summary Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
     * @param {string} encryptedAccountId The account ID.
     * @param {Array<number>} [champion] Set of champion IDs for filtering the matchlist.
     * @param {Array<number>} [queue] Set of queue IDs for filtering the matchlist.
     * @param {Array<number>} [season] Set of season IDs for filtering the matchlist.
     * @param {number} [endTime] The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param {number} [beginTime] The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param {number} [endIndex] The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
     * @param {number} [beginIndex] The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchV4Api
     */
    public matchV4GetMatchlist(encryptedAccountId: string, champion?: Array<number>, queue?: Array<number>, season?: Array<number>, endTime?: number, beginTime?: number, endIndex?: number, beginIndex?: number, options?: any) {
        return MatchV4ApiFp(this.configuration).matchV4GetMatchlist(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, options)(this.fetch, this.basePath);
    }

}

/**
 * SpectatorV4Api - fetch parameter creator
 * @export
 */
export const SpectatorV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current game information for the given summoner ID.
         * @summary Get current game information for the given summoner ID.
         * @param {string} encryptedSummonerId The ID of the summoner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling spectatorV4GetCurrentGameInfoBySummoner.');
            }
            const localVarPath = `/lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}`
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of featured games.
         * @summary Get list of featured games.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spectatorV4GetFeaturedGames(options: any = {}): FetchArgs {
            const localVarPath = `/lol/spectator/v4/featured-games`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpectatorV4Api - functional programming interface
 * @export
 */
export const SpectatorV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get current game information for the given summoner ID.
         * @summary Get current game information for the given summoner ID.
         * @param {string} encryptedSummonerId The ID of the summoner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpectatorV4CurrentGameInfo> {
            const localVarFetchArgs = SpectatorV4ApiFetchParamCreator(configuration).spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get list of featured games.
         * @summary Get list of featured games.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spectatorV4GetFeaturedGames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpectatorV4FeaturedGames> {
            const localVarFetchArgs = SpectatorV4ApiFetchParamCreator(configuration).spectatorV4GetFeaturedGames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SpectatorV4Api - factory interface
 * @export
 */
export const SpectatorV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get current game information for the given summoner ID.
         * @summary Get current game information for the given summoner ID.
         * @param {string} encryptedSummonerId The ID of the summoner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId: string, options?: any) {
            return SpectatorV4ApiFp(configuration).spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId, options)(fetch, basePath);
        },
        /**
         * Get list of featured games.
         * @summary Get list of featured games.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spectatorV4GetFeaturedGames(options?: any) {
            return SpectatorV4ApiFp(configuration).spectatorV4GetFeaturedGames(options)(fetch, basePath);
        },
    };
};

/**
 * SpectatorV4Api - object-oriented interface
 * @export
 * @class SpectatorV4Api
 * @extends {BaseAPI}
 */
export class SpectatorV4Api extends BaseAPI {
    /**
     * Get current game information for the given summoner ID.
     * @summary Get current game information for the given summoner ID.
     * @param {string} encryptedSummonerId The ID of the summoner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpectatorV4Api
     */
    public spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId: string, options?: any) {
        return SpectatorV4ApiFp(this.configuration).spectatorV4GetCurrentGameInfoBySummoner(encryptedSummonerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get list of featured games.
     * @summary Get list of featured games.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpectatorV4Api
     */
    public spectatorV4GetFeaturedGames(options?: any) {
        return SpectatorV4ApiFp(this.configuration).spectatorV4GetFeaturedGames(options)(this.fetch, this.basePath);
    }

}

/**
 * SummonerV4Api - fetch parameter creator
 * @export
 */
export const SummonerV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a summoner by account ID.
         * @summary Get a summoner by account ID.
         * @param {string} encryptedAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetByAccountId(encryptedAccountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedAccountId' is not null or undefined
            if (encryptedAccountId === null || encryptedAccountId === undefined) {
                throw new RequiredError('encryptedAccountId','Required parameter encryptedAccountId was null or undefined when calling summonerV4GetByAccountId.');
            }
            const localVarPath = `/lol/summoner/v4/summoners/by-account/{encryptedAccountId}`
                .replace(`{${"encryptedAccountId"}}`, encodeURIComponent(String(encryptedAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summoner by PUUID.
         * @summary Get a summoner by PUUID.
         * @param {string} encryptedPUUID Summoner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetByPUUID(encryptedPUUID: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedPUUID' is not null or undefined
            if (encryptedPUUID === null || encryptedPUUID === undefined) {
                throw new RequiredError('encryptedPUUID','Required parameter encryptedPUUID was null or undefined when calling summonerV4GetByPUUID.');
            }
            const localVarPath = `/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}`
                .replace(`{${"encryptedPUUID"}}`, encodeURIComponent(String(encryptedPUUID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summoner by summoner ID.
         * @summary Get a summoner by summoner ID.
         * @param {string} encryptedSummonerId Summoner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetBySummonerId(encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling summonerV4GetBySummonerId.');
            }
            const localVarPath = `/lol/summoner/v4/summoners/{encryptedSummonerId}`
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summoner by summoner name.
         * @summary Get a summoner by summoner name.
         * @param {string} summonerName Summoner Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetBySummonerName(summonerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'summonerName' is not null or undefined
            if (summonerName === null || summonerName === undefined) {
                throw new RequiredError('summonerName','Required parameter summonerName was null or undefined when calling summonerV4GetBySummonerName.');
            }
            const localVarPath = `/lol/summoner/v4/summoners/by-name/{summonerName}`
                .replace(`{${"summonerName"}}`, encodeURIComponent(String(summonerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SummonerV4Api - functional programming interface
 * @export
 */
export const SummonerV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a summoner by account ID.
         * @summary Get a summoner by account ID.
         * @param {string} encryptedAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetByAccountId(encryptedAccountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SummonerV4SummonerDTO> {
            const localVarFetchArgs = SummonerV4ApiFetchParamCreator(configuration).summonerV4GetByAccountId(encryptedAccountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a summoner by PUUID.
         * @summary Get a summoner by PUUID.
         * @param {string} encryptedPUUID Summoner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetByPUUID(encryptedPUUID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SummonerV4SummonerDTO> {
            const localVarFetchArgs = SummonerV4ApiFetchParamCreator(configuration).summonerV4GetByPUUID(encryptedPUUID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a summoner by summoner ID.
         * @summary Get a summoner by summoner ID.
         * @param {string} encryptedSummonerId Summoner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetBySummonerId(encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SummonerV4SummonerDTO> {
            const localVarFetchArgs = SummonerV4ApiFetchParamCreator(configuration).summonerV4GetBySummonerId(encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a summoner by summoner name.
         * @summary Get a summoner by summoner name.
         * @param {string} summonerName Summoner Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetBySummonerName(summonerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SummonerV4SummonerDTO> {
            const localVarFetchArgs = SummonerV4ApiFetchParamCreator(configuration).summonerV4GetBySummonerName(summonerName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SummonerV4Api - factory interface
 * @export
 */
export const SummonerV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a summoner by account ID.
         * @summary Get a summoner by account ID.
         * @param {string} encryptedAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetByAccountId(encryptedAccountId: string, options?: any) {
            return SummonerV4ApiFp(configuration).summonerV4GetByAccountId(encryptedAccountId, options)(fetch, basePath);
        },
        /**
         * Get a summoner by PUUID.
         * @summary Get a summoner by PUUID.
         * @param {string} encryptedPUUID Summoner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetByPUUID(encryptedPUUID: string, options?: any) {
            return SummonerV4ApiFp(configuration).summonerV4GetByPUUID(encryptedPUUID, options)(fetch, basePath);
        },
        /**
         * Get a summoner by summoner ID.
         * @summary Get a summoner by summoner ID.
         * @param {string} encryptedSummonerId Summoner ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetBySummonerId(encryptedSummonerId: string, options?: any) {
            return SummonerV4ApiFp(configuration).summonerV4GetBySummonerId(encryptedSummonerId, options)(fetch, basePath);
        },
        /**
         * Get a summoner by summoner name.
         * @summary Get a summoner by summoner name.
         * @param {string} summonerName Summoner Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        summonerV4GetBySummonerName(summonerName: string, options?: any) {
            return SummonerV4ApiFp(configuration).summonerV4GetBySummonerName(summonerName, options)(fetch, basePath);
        },
    };
};

/**
 * SummonerV4Api - object-oriented interface
 * @export
 * @class SummonerV4Api
 * @extends {BaseAPI}
 */
export class SummonerV4Api extends BaseAPI {
    /**
     * Get a summoner by account ID.
     * @summary Get a summoner by account ID.
     * @param {string} encryptedAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummonerV4Api
     */
    public summonerV4GetByAccountId(encryptedAccountId: string, options?: any) {
        return SummonerV4ApiFp(this.configuration).summonerV4GetByAccountId(encryptedAccountId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a summoner by PUUID.
     * @summary Get a summoner by PUUID.
     * @param {string} encryptedPUUID Summoner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummonerV4Api
     */
    public summonerV4GetByPUUID(encryptedPUUID: string, options?: any) {
        return SummonerV4ApiFp(this.configuration).summonerV4GetByPUUID(encryptedPUUID, options)(this.fetch, this.basePath);
    }

    /**
     * Get a summoner by summoner ID.
     * @summary Get a summoner by summoner ID.
     * @param {string} encryptedSummonerId Summoner ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummonerV4Api
     */
    public summonerV4GetBySummonerId(encryptedSummonerId: string, options?: any) {
        return SummonerV4ApiFp(this.configuration).summonerV4GetBySummonerId(encryptedSummonerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a summoner by summoner name.
     * @summary Get a summoner by summoner name.
     * @param {string} summonerName Summoner Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummonerV4Api
     */
    public summonerV4GetBySummonerName(summonerName: string, options?: any) {
        return SummonerV4ApiFp(this.configuration).summonerV4GetBySummonerName(summonerName, options)(this.fetch, this.basePath);
    }

}

/**
 * ThirdPartyCodeV4Api - fetch parameter creator
 * @export
 */
export const ThirdPartyCodeV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get third party code for a given summoner ID.
         * @summary Get third party code for a given summoner ID.
         * @param {string} encryptedSummonerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'encryptedSummonerId' is not null or undefined
            if (encryptedSummonerId === null || encryptedSummonerId === undefined) {
                throw new RequiredError('encryptedSummonerId','Required parameter encryptedSummonerId was null or undefined when calling thirdPartyCodeV4GetThirdPartyCodeBySummonerId.');
            }
            const localVarPath = `/lol/platform/v4/third-party-code/by-summoner/{encryptedSummonerId}`
                .replace(`{${"encryptedSummonerId"}}`, encodeURIComponent(String(encryptedSummonerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThirdPartyCodeV4Api - functional programming interface
 * @export
 */
export const ThirdPartyCodeV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get third party code for a given summoner ID.
         * @summary Get third party code for a given summoner ID.
         * @param {string} encryptedSummonerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ThirdPartyCodeV4ApiFetchParamCreator(configuration).thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ThirdPartyCodeV4Api - factory interface
 * @export
 */
export const ThirdPartyCodeV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get third party code for a given summoner ID.
         * @summary Get third party code for a given summoner ID.
         * @param {string} encryptedSummonerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId: string, options?: any) {
            return ThirdPartyCodeV4ApiFp(configuration).thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId, options)(fetch, basePath);
        },
    };
};

/**
 * ThirdPartyCodeV4Api - object-oriented interface
 * @export
 * @class ThirdPartyCodeV4Api
 * @extends {BaseAPI}
 */
export class ThirdPartyCodeV4Api extends BaseAPI {
    /**
     * Get third party code for a given summoner ID.
     * @summary Get third party code for a given summoner ID.
     * @param {string} encryptedSummonerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyCodeV4Api
     */
    public thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId: string, options?: any) {
        return ThirdPartyCodeV4ApiFp(this.configuration).thirdPartyCodeV4GetThirdPartyCodeBySummonerId(encryptedSummonerId, options)(this.fetch, this.basePath);
    }

}

/**
 * TournamentStubV4Api - fetch parameter creator
 * @export
 */
export const TournamentStubV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a mock tournament code for the given tournament.
         * @summary Create a mock tournament code for the given tournament.
         * @param {number} tournamentId The tournament ID
         * @param {TournamentStubV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
         * @param {number} [count] The number of codes to create (max 1000)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentStubV4TournamentCodeParameters, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentId' is not null or undefined
            if (tournamentId === null || tournamentId === undefined) {
                throw new RequiredError('tournamentId','Required parameter tournamentId was null or undefined when calling tournamentStubV4CreateTournamentCode.');
            }
            // verify required parameter 'tournamentCodeParameters' is not null or undefined
            if (tournamentCodeParameters === null || tournamentCodeParameters === undefined) {
                throw new RequiredError('tournamentCodeParameters','Required parameter tournamentCodeParameters was null or undefined when calling tournamentStubV4CreateTournamentCode.');
            }
            const localVarPath = `/lol/tournament-stub/v4/codes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (tournamentId !== undefined) {
                localVarQueryParameter['tournamentId'] = tournamentId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentStubV4TournamentCodeParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tournamentCodeParameters || {}) : (tournamentCodeParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a mock list of lobby events by tournament code.
         * @summary Gets a mock list of lobby events by tournament code.
         * @param {string} tournamentCode The short code to look up lobby events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4GetLobbyEventsByCode(tournamentCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentCode' is not null or undefined
            if (tournamentCode === null || tournamentCode === undefined) {
                throw new RequiredError('tournamentCode','Required parameter tournamentCode was null or undefined when calling tournamentStubV4GetLobbyEventsByCode.');
            }
            const localVarPath = `/lol/tournament-stub/v4/lobby-events/by-code/{tournamentCode}`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a mock tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
         * @summary Creates a mock tournament provider and returns its ID.
         * @param {TournamentStubV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4RegisterProviderData(providerRegistrationParameters: TournamentStubV4ProviderRegistrationParameters, options: any = {}): FetchArgs {
            // verify required parameter 'providerRegistrationParameters' is not null or undefined
            if (providerRegistrationParameters === null || providerRegistrationParameters === undefined) {
                throw new RequiredError('providerRegistrationParameters','Required parameter providerRegistrationParameters was null or undefined when calling tournamentStubV4RegisterProviderData.');
            }
            const localVarPath = `/lol/tournament-stub/v4/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentStubV4ProviderRegistrationParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(providerRegistrationParameters || {}) : (providerRegistrationParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a mock tournament and returns its ID.
         * @summary Creates a mock tournament and returns its ID.
         * @param {TournamentStubV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4RegisterTournament(tournamentRegistrationParameters: TournamentStubV4TournamentRegistrationParameters, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentRegistrationParameters' is not null or undefined
            if (tournamentRegistrationParameters === null || tournamentRegistrationParameters === undefined) {
                throw new RequiredError('tournamentRegistrationParameters','Required parameter tournamentRegistrationParameters was null or undefined when calling tournamentStubV4RegisterTournament.');
            }
            const localVarPath = `/lol/tournament-stub/v4/tournaments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentStubV4TournamentRegistrationParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tournamentRegistrationParameters || {}) : (tournamentRegistrationParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentStubV4Api - functional programming interface
 * @export
 */
export const TournamentStubV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a mock tournament code for the given tournament.
         * @summary Create a mock tournament code for the given tournament.
         * @param {number} tournamentId The tournament ID
         * @param {TournamentStubV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
         * @param {number} [count] The number of codes to create (max 1000)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentStubV4TournamentCodeParameters, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TournamentStubV4ApiFetchParamCreator(configuration).tournamentStubV4CreateTournamentCode(tournamentId, tournamentCodeParameters, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a mock list of lobby events by tournament code.
         * @summary Gets a mock list of lobby events by tournament code.
         * @param {string} tournamentCode The short code to look up lobby events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4GetLobbyEventsByCode(tournamentCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentStubV4LobbyEventDTOWrapper> {
            const localVarFetchArgs = TournamentStubV4ApiFetchParamCreator(configuration).tournamentStubV4GetLobbyEventsByCode(tournamentCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a mock tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
         * @summary Creates a mock tournament provider and returns its ID.
         * @param {TournamentStubV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4RegisterProviderData(providerRegistrationParameters: TournamentStubV4ProviderRegistrationParameters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = TournamentStubV4ApiFetchParamCreator(configuration).tournamentStubV4RegisterProviderData(providerRegistrationParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a mock tournament and returns its ID.
         * @summary Creates a mock tournament and returns its ID.
         * @param {TournamentStubV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4RegisterTournament(tournamentRegistrationParameters: TournamentStubV4TournamentRegistrationParameters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = TournamentStubV4ApiFetchParamCreator(configuration).tournamentStubV4RegisterTournament(tournamentRegistrationParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TournamentStubV4Api - factory interface
 * @export
 */
export const TournamentStubV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a mock tournament code for the given tournament.
         * @summary Create a mock tournament code for the given tournament.
         * @param {number} tournamentId The tournament ID
         * @param {TournamentStubV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
         * @param {number} [count] The number of codes to create (max 1000)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentStubV4TournamentCodeParameters, count?: number, options?: any) {
            return TournamentStubV4ApiFp(configuration).tournamentStubV4CreateTournamentCode(tournamentId, tournamentCodeParameters, count, options)(fetch, basePath);
        },
        /**
         * Gets a mock list of lobby events by tournament code.
         * @summary Gets a mock list of lobby events by tournament code.
         * @param {string} tournamentCode The short code to look up lobby events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4GetLobbyEventsByCode(tournamentCode: string, options?: any) {
            return TournamentStubV4ApiFp(configuration).tournamentStubV4GetLobbyEventsByCode(tournamentCode, options)(fetch, basePath);
        },
        /**
         * Creates a mock tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
         * @summary Creates a mock tournament provider and returns its ID.
         * @param {TournamentStubV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4RegisterProviderData(providerRegistrationParameters: TournamentStubV4ProviderRegistrationParameters, options?: any) {
            return TournamentStubV4ApiFp(configuration).tournamentStubV4RegisterProviderData(providerRegistrationParameters, options)(fetch, basePath);
        },
        /**
         * Creates a mock tournament and returns its ID.
         * @summary Creates a mock tournament and returns its ID.
         * @param {TournamentStubV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentStubV4RegisterTournament(tournamentRegistrationParameters: TournamentStubV4TournamentRegistrationParameters, options?: any) {
            return TournamentStubV4ApiFp(configuration).tournamentStubV4RegisterTournament(tournamentRegistrationParameters, options)(fetch, basePath);
        },
    };
};

/**
 * TournamentStubV4Api - object-oriented interface
 * @export
 * @class TournamentStubV4Api
 * @extends {BaseAPI}
 */
export class TournamentStubV4Api extends BaseAPI {
    /**
     * Create a mock tournament code for the given tournament.
     * @summary Create a mock tournament code for the given tournament.
     * @param {number} tournamentId The tournament ID
     * @param {TournamentStubV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
     * @param {number} [count] The number of codes to create (max 1000)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentStubV4Api
     */
    public tournamentStubV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentStubV4TournamentCodeParameters, count?: number, options?: any) {
        return TournamentStubV4ApiFp(this.configuration).tournamentStubV4CreateTournamentCode(tournamentId, tournamentCodeParameters, count, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a mock list of lobby events by tournament code.
     * @summary Gets a mock list of lobby events by tournament code.
     * @param {string} tournamentCode The short code to look up lobby events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentStubV4Api
     */
    public tournamentStubV4GetLobbyEventsByCode(tournamentCode: string, options?: any) {
        return TournamentStubV4ApiFp(this.configuration).tournamentStubV4GetLobbyEventsByCode(tournamentCode, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a mock tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
     * @summary Creates a mock tournament provider and returns its ID.
     * @param {TournamentStubV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentStubV4Api
     */
    public tournamentStubV4RegisterProviderData(providerRegistrationParameters: TournamentStubV4ProviderRegistrationParameters, options?: any) {
        return TournamentStubV4ApiFp(this.configuration).tournamentStubV4RegisterProviderData(providerRegistrationParameters, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a mock tournament and returns its ID.
     * @summary Creates a mock tournament and returns its ID.
     * @param {TournamentStubV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentStubV4Api
     */
    public tournamentStubV4RegisterTournament(tournamentRegistrationParameters: TournamentStubV4TournamentRegistrationParameters, options?: any) {
        return TournamentStubV4ApiFp(this.configuration).tournamentStubV4RegisterTournament(tournamentRegistrationParameters, options)(this.fetch, this.basePath);
    }

}

/**
 * TournamentV4Api - fetch parameter creator
 * @export
 */
export const TournamentV4ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a tournament code for the given tournament.
         * @summary Create a tournament code for the given tournament.
         * @param {number} tournamentId The tournament ID
         * @param {TournamentV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
         * @param {number} [count] The number of codes to create (max 1000)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentV4TournamentCodeParameters, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentId' is not null or undefined
            if (tournamentId === null || tournamentId === undefined) {
                throw new RequiredError('tournamentId','Required parameter tournamentId was null or undefined when calling tournamentV4CreateTournamentCode.');
            }
            // verify required parameter 'tournamentCodeParameters' is not null or undefined
            if (tournamentCodeParameters === null || tournamentCodeParameters === undefined) {
                throw new RequiredError('tournamentCodeParameters','Required parameter tournamentCodeParameters was null or undefined when calling tournamentV4CreateTournamentCode.');
            }
            const localVarPath = `/lol/tournament/v4/codes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (tournamentId !== undefined) {
                localVarQueryParameter['tournamentId'] = tournamentId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentV4TournamentCodeParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tournamentCodeParameters || {}) : (tournamentCodeParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of lobby events by tournament code.
         * @summary Gets a list of lobby events by tournament code.
         * @param {string} tournamentCode The short code to look up lobby events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4GetLobbyEventsByCode(tournamentCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentCode' is not null or undefined
            if (tournamentCode === null || tournamentCode === undefined) {
                throw new RequiredError('tournamentCode','Required parameter tournamentCode was null or undefined when calling tournamentV4GetLobbyEventsByCode.');
            }
            const localVarPath = `/lol/tournament/v4/lobby-events/by-code/{tournamentCode}`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the tournament code DTO associated with a tournament code string.
         * @summary Returns the tournament code DTO associated with a tournament code string.
         * @param {string} tournamentCode The tournament code string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4GetTournamentCode(tournamentCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentCode' is not null or undefined
            if (tournamentCode === null || tournamentCode === undefined) {
                throw new RequiredError('tournamentCode','Required parameter tournamentCode was null or undefined when calling tournamentV4GetTournamentCode.');
            }
            const localVarPath = `/lol/tournament/v4/codes/{tournamentCode}`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
         * @summary Creates a tournament provider and returns its ID.
         * @param {TournamentV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4RegisterProviderData(providerRegistrationParameters: TournamentV4ProviderRegistrationParameters, options: any = {}): FetchArgs {
            // verify required parameter 'providerRegistrationParameters' is not null or undefined
            if (providerRegistrationParameters === null || providerRegistrationParameters === undefined) {
                throw new RequiredError('providerRegistrationParameters','Required parameter providerRegistrationParameters was null or undefined when calling tournamentV4RegisterProviderData.');
            }
            const localVarPath = `/lol/tournament/v4/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentV4ProviderRegistrationParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(providerRegistrationParameters || {}) : (providerRegistrationParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a tournament and returns its ID.
         * @summary Creates a tournament and returns its ID.
         * @param {TournamentV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4RegisterTournament(tournamentRegistrationParameters: TournamentV4TournamentRegistrationParameters, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentRegistrationParameters' is not null or undefined
            if (tournamentRegistrationParameters === null || tournamentRegistrationParameters === undefined) {
                throw new RequiredError('tournamentRegistrationParameters','Required parameter tournamentRegistrationParameters was null or undefined when calling tournamentV4RegisterTournament.');
            }
            const localVarPath = `/lol/tournament/v4/tournaments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentV4TournamentRegistrationParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tournamentRegistrationParameters || {}) : (tournamentRegistrationParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the pick type, map, spectator type, or allowed summoners for a code.
         * @summary Update the pick type, map, spectator type, or allowed summoners for a code.
         * @param {string} tournamentCode The tournament code to update
         * @param {TournamentV4TournamentCodeUpdateParameters} [tournamentCodeUpdateParameters] The fields to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4UpdateCode(tournamentCode: string, tournamentCodeUpdateParameters?: TournamentV4TournamentCodeUpdateParameters, options: any = {}): FetchArgs {
            // verify required parameter 'tournamentCode' is not null or undefined
            if (tournamentCode === null || tournamentCode === undefined) {
                throw new RequiredError('tournamentCode','Required parameter tournamentCode was null or undefined when calling tournamentV4UpdateCode.');
            }
            const localVarPath = `/lol/tournament/v4/codes/{tournamentCode}`
                .replace(`{${"tournamentCode"}}`, encodeURIComponent(String(tournamentCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Riot-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Riot-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Riot-Token"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TournamentV4TournamentCodeUpdateParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tournamentCodeUpdateParameters || {}) : (tournamentCodeUpdateParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentV4Api - functional programming interface
 * @export
 */
export const TournamentV4ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a tournament code for the given tournament.
         * @summary Create a tournament code for the given tournament.
         * @param {number} tournamentId The tournament ID
         * @param {TournamentV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
         * @param {number} [count] The number of codes to create (max 1000)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentV4TournamentCodeParameters, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TournamentV4ApiFetchParamCreator(configuration).tournamentV4CreateTournamentCode(tournamentId, tournamentCodeParameters, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of lobby events by tournament code.
         * @summary Gets a list of lobby events by tournament code.
         * @param {string} tournamentCode The short code to look up lobby events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4GetLobbyEventsByCode(tournamentCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentV4LobbyEventDTOWrapper> {
            const localVarFetchArgs = TournamentV4ApiFetchParamCreator(configuration).tournamentV4GetLobbyEventsByCode(tournamentCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the tournament code DTO associated with a tournament code string.
         * @summary Returns the tournament code DTO associated with a tournament code string.
         * @param {string} tournamentCode The tournament code string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4GetTournamentCode(tournamentCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentV4TournamentCodeDTO> {
            const localVarFetchArgs = TournamentV4ApiFetchParamCreator(configuration).tournamentV4GetTournamentCode(tournamentCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
         * @summary Creates a tournament provider and returns its ID.
         * @param {TournamentV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4RegisterProviderData(providerRegistrationParameters: TournamentV4ProviderRegistrationParameters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = TournamentV4ApiFetchParamCreator(configuration).tournamentV4RegisterProviderData(providerRegistrationParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a tournament and returns its ID.
         * @summary Creates a tournament and returns its ID.
         * @param {TournamentV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4RegisterTournament(tournamentRegistrationParameters: TournamentV4TournamentRegistrationParameters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = TournamentV4ApiFetchParamCreator(configuration).tournamentV4RegisterTournament(tournamentRegistrationParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the pick type, map, spectator type, or allowed summoners for a code.
         * @summary Update the pick type, map, spectator type, or allowed summoners for a code.
         * @param {string} tournamentCode The tournament code to update
         * @param {TournamentV4TournamentCodeUpdateParameters} [tournamentCodeUpdateParameters] The fields to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4UpdateCode(tournamentCode: string, tournamentCodeUpdateParameters?: TournamentV4TournamentCodeUpdateParameters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TournamentV4ApiFetchParamCreator(configuration).tournamentV4UpdateCode(tournamentCode, tournamentCodeUpdateParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TournamentV4Api - factory interface
 * @export
 */
export const TournamentV4ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a tournament code for the given tournament.
         * @summary Create a tournament code for the given tournament.
         * @param {number} tournamentId The tournament ID
         * @param {TournamentV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
         * @param {number} [count] The number of codes to create (max 1000)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentV4TournamentCodeParameters, count?: number, options?: any) {
            return TournamentV4ApiFp(configuration).tournamentV4CreateTournamentCode(tournamentId, tournamentCodeParameters, count, options)(fetch, basePath);
        },
        /**
         * Gets a list of lobby events by tournament code.
         * @summary Gets a list of lobby events by tournament code.
         * @param {string} tournamentCode The short code to look up lobby events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4GetLobbyEventsByCode(tournamentCode: string, options?: any) {
            return TournamentV4ApiFp(configuration).tournamentV4GetLobbyEventsByCode(tournamentCode, options)(fetch, basePath);
        },
        /**
         * Returns the tournament code DTO associated with a tournament code string.
         * @summary Returns the tournament code DTO associated with a tournament code string.
         * @param {string} tournamentCode The tournament code string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4GetTournamentCode(tournamentCode: string, options?: any) {
            return TournamentV4ApiFp(configuration).tournamentV4GetTournamentCode(tournamentCode, options)(fetch, basePath);
        },
        /**
         * Creates a tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
         * @summary Creates a tournament provider and returns its ID.
         * @param {TournamentV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4RegisterProviderData(providerRegistrationParameters: TournamentV4ProviderRegistrationParameters, options?: any) {
            return TournamentV4ApiFp(configuration).tournamentV4RegisterProviderData(providerRegistrationParameters, options)(fetch, basePath);
        },
        /**
         * Creates a tournament and returns its ID.
         * @summary Creates a tournament and returns its ID.
         * @param {TournamentV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4RegisterTournament(tournamentRegistrationParameters: TournamentV4TournamentRegistrationParameters, options?: any) {
            return TournamentV4ApiFp(configuration).tournamentV4RegisterTournament(tournamentRegistrationParameters, options)(fetch, basePath);
        },
        /**
         * Update the pick type, map, spectator type, or allowed summoners for a code.
         * @summary Update the pick type, map, spectator type, or allowed summoners for a code.
         * @param {string} tournamentCode The tournament code to update
         * @param {TournamentV4TournamentCodeUpdateParameters} [tournamentCodeUpdateParameters] The fields to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentV4UpdateCode(tournamentCode: string, tournamentCodeUpdateParameters?: TournamentV4TournamentCodeUpdateParameters, options?: any) {
            return TournamentV4ApiFp(configuration).tournamentV4UpdateCode(tournamentCode, tournamentCodeUpdateParameters, options)(fetch, basePath);
        },
    };
};

/**
 * TournamentV4Api - object-oriented interface
 * @export
 * @class TournamentV4Api
 * @extends {BaseAPI}
 */
export class TournamentV4Api extends BaseAPI {
    /**
     * Create a tournament code for the given tournament.
     * @summary Create a tournament code for the given tournament.
     * @param {number} tournamentId The tournament ID
     * @param {TournamentV4TournamentCodeParameters} tournamentCodeParameters Metadata for the generated code
     * @param {number} [count] The number of codes to create (max 1000)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentV4Api
     */
    public tournamentV4CreateTournamentCode(tournamentId: number, tournamentCodeParameters: TournamentV4TournamentCodeParameters, count?: number, options?: any) {
        return TournamentV4ApiFp(this.configuration).tournamentV4CreateTournamentCode(tournamentId, tournamentCodeParameters, count, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of lobby events by tournament code.
     * @summary Gets a list of lobby events by tournament code.
     * @param {string} tournamentCode The short code to look up lobby events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentV4Api
     */
    public tournamentV4GetLobbyEventsByCode(tournamentCode: string, options?: any) {
        return TournamentV4ApiFp(this.configuration).tournamentV4GetLobbyEventsByCode(tournamentCode, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the tournament code DTO associated with a tournament code string.
     * @summary Returns the tournament code DTO associated with a tournament code string.
     * @param {string} tournamentCode The tournament code string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentV4Api
     */
    public tournamentV4GetTournamentCode(tournamentCode: string, options?: any) {
        return TournamentV4ApiFp(this.configuration).tournamentV4GetTournamentCode(tournamentCode, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a tournament provider and returns its ID. ## Implementation Notes Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
     * @summary Creates a tournament provider and returns its ID.
     * @param {TournamentV4ProviderRegistrationParameters} providerRegistrationParameters The provider definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentV4Api
     */
    public tournamentV4RegisterProviderData(providerRegistrationParameters: TournamentV4ProviderRegistrationParameters, options?: any) {
        return TournamentV4ApiFp(this.configuration).tournamentV4RegisterProviderData(providerRegistrationParameters, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a tournament and returns its ID.
     * @summary Creates a tournament and returns its ID.
     * @param {TournamentV4TournamentRegistrationParameters} tournamentRegistrationParameters The tournament definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentV4Api
     */
    public tournamentV4RegisterTournament(tournamentRegistrationParameters: TournamentV4TournamentRegistrationParameters, options?: any) {
        return TournamentV4ApiFp(this.configuration).tournamentV4RegisterTournament(tournamentRegistrationParameters, options)(this.fetch, this.basePath);
    }

    /**
     * Update the pick type, map, spectator type, or allowed summoners for a code.
     * @summary Update the pick type, map, spectator type, or allowed summoners for a code.
     * @param {string} tournamentCode The tournament code to update
     * @param {TournamentV4TournamentCodeUpdateParameters} [tournamentCodeUpdateParameters] The fields to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentV4Api
     */
    public tournamentV4UpdateCode(tournamentCode: string, tournamentCodeUpdateParameters?: TournamentV4TournamentCodeUpdateParameters, options?: any) {
        return TournamentV4ApiFp(this.configuration).tournamentV4UpdateCode(tournamentCode, tournamentCodeUpdateParameters, options)(this.fetch, this.basePath);
    }

}

