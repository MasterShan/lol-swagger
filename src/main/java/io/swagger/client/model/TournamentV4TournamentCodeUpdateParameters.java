/*
 * Riot API
 *  OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## Download OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([download file](../openapi-3.0.0.json), [view ui](?openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([download file](../openapi-3.0.0.min.json), [view ui](?openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([download file](../openapi-3.0.0.yml), [view ui](?openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([download file](../openapi-3.0.0.min.yml), [view ui](?openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([download file](../swaggerspec-2.0.json), [view ui](?swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([download file](../swaggerspec-2.0.min.json), [view ui](?swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([download file](../swaggerspec-2.0.yml), [view ui](?swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([download file](../swaggerspec-2.0.min.yml), [view ui](?swaggerspec-2.0.min.yml)) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.org/MingweiSamuel/riotapi-schema/builds) daily. *** 
 *
 * OpenAPI spec version: dfa1c0f97b9cc62a43c9fb91daa1b91b3e9485c2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * TournamentV4TournamentCodeUpdateParameters
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-07-17T15:57:39.031+02:00")
public class TournamentV4TournamentCodeUpdateParameters {
  /**
   * The spectator type              (Legal values:  NONE,  LOBBYONLY,  ALL)
   */
  @JsonAdapter(SpectatorTypeEnum.Adapter.class)
  public enum SpectatorTypeEnum {
    NONE("NONE"),
    
    LOBBYONLY("LOBBYONLY"),
    
    ALL("ALL");

    private String value;

    SpectatorTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpectatorTypeEnum fromValue(String text) {
      for (SpectatorTypeEnum b : SpectatorTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SpectatorTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpectatorTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpectatorTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SpectatorTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("spectatorType")
  private SpectatorTypeEnum spectatorType = null;

  /**
   * The pick type              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
   */
  @JsonAdapter(PickTypeEnum.Adapter.class)
  public enum PickTypeEnum {
    BLIND_PICK("BLIND_PICK"),
    
    DRAFT_MODE("DRAFT_MODE"),
    
    ALL_RANDOM("ALL_RANDOM"),
    
    TOURNAMENT_DRAFT("TOURNAMENT_DRAFT");

    private String value;

    PickTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PickTypeEnum fromValue(String text) {
      for (PickTypeEnum b : PickTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PickTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PickTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PickTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PickTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("pickType")
  private PickTypeEnum pickType = null;

  @SerializedName("allowedSummonerIds")
  private List<String> allowedSummonerIds = null;

  /**
   * The map type              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
   */
  @JsonAdapter(MapTypeEnum.Adapter.class)
  public enum MapTypeEnum {
    SUMMONERS_RIFT("SUMMONERS_RIFT"),
    
    TWISTED_TREELINE("TWISTED_TREELINE"),
    
    HOWLING_ABYSS("HOWLING_ABYSS");

    private String value;

    MapTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MapTypeEnum fromValue(String text) {
      for (MapTypeEnum b : MapTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<MapTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MapTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MapTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return MapTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("mapType")
  private MapTypeEnum mapType = null;

  public TournamentV4TournamentCodeUpdateParameters spectatorType(SpectatorTypeEnum spectatorType) {
    this.spectatorType = spectatorType;
    return this;
  }

   /**
   * The spectator type              (Legal values:  NONE,  LOBBYONLY,  ALL)
   * @return spectatorType
  **/
  @ApiModelProperty(required = true, value = "The spectator type              (Legal values:  NONE,  LOBBYONLY,  ALL)")
  public SpectatorTypeEnum getSpectatorType() {
    return spectatorType;
  }

  public void setSpectatorType(SpectatorTypeEnum spectatorType) {
    this.spectatorType = spectatorType;
  }

  public TournamentV4TournamentCodeUpdateParameters pickType(PickTypeEnum pickType) {
    this.pickType = pickType;
    return this;
  }

   /**
   * The pick type              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
   * @return pickType
  **/
  @ApiModelProperty(required = true, value = "The pick type              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)")
  public PickTypeEnum getPickType() {
    return pickType;
  }

  public void setPickType(PickTypeEnum pickType) {
    this.pickType = pickType;
  }

  public TournamentV4TournamentCodeUpdateParameters allowedSummonerIds(List<String> allowedSummonerIds) {
    this.allowedSummonerIds = allowedSummonerIds;
    return this;
  }

  public TournamentV4TournamentCodeUpdateParameters addAllowedSummonerIdsItem(String allowedSummonerIdsItem) {
    if (this.allowedSummonerIds == null) {
      this.allowedSummonerIds = new ArrayList<String>();
    }
    this.allowedSummonerIds.add(allowedSummonerIdsItem);
    return this;
  }

   /**
   * Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
   * @return allowedSummonerIds
  **/
  @ApiModelProperty(value = "Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.")
  public List<String> getAllowedSummonerIds() {
    return allowedSummonerIds;
  }

  public void setAllowedSummonerIds(List<String> allowedSummonerIds) {
    this.allowedSummonerIds = allowedSummonerIds;
  }

  public TournamentV4TournamentCodeUpdateParameters mapType(MapTypeEnum mapType) {
    this.mapType = mapType;
    return this;
  }

   /**
   * The map type              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)
   * @return mapType
  **/
  @ApiModelProperty(required = true, value = "The map type              (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS)")
  public MapTypeEnum getMapType() {
    return mapType;
  }

  public void setMapType(MapTypeEnum mapType) {
    this.mapType = mapType;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TournamentV4TournamentCodeUpdateParameters tournamentV4TournamentCodeUpdateParameters = (TournamentV4TournamentCodeUpdateParameters) o;
    return Objects.equals(this.spectatorType, tournamentV4TournamentCodeUpdateParameters.spectatorType) &&
        Objects.equals(this.pickType, tournamentV4TournamentCodeUpdateParameters.pickType) &&
        Objects.equals(this.allowedSummonerIds, tournamentV4TournamentCodeUpdateParameters.allowedSummonerIds) &&
        Objects.equals(this.mapType, tournamentV4TournamentCodeUpdateParameters.mapType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(spectatorType, pickType, allowedSummonerIds, mapType);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TournamentV4TournamentCodeUpdateParameters {\n");
    
    sb.append("    spectatorType: ").append(toIndentedString(spectatorType)).append("\n");
    sb.append("    pickType: ").append(toIndentedString(pickType)).append("\n");
    sb.append("    allowedSummonerIds: ").append(toIndentedString(allowedSummonerIds)).append("\n");
    sb.append("    mapType: ").append(toIndentedString(mapType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

