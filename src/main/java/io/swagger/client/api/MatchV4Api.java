/*
 * Riot API
 *  OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## Download OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([download file](../openapi-3.0.0.json), [view ui](?openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([download file](../openapi-3.0.0.min.json), [view ui](?openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([download file](../openapi-3.0.0.yml), [view ui](?openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([download file](../openapi-3.0.0.min.yml), [view ui](?openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([download file](../swaggerspec-2.0.json), [view ui](?swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([download file](../swaggerspec-2.0.min.json), [view ui](?swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([download file](../swaggerspec-2.0.yml), [view ui](?swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([download file](../swaggerspec-2.0.min.yml), [view ui](?swaggerspec-2.0.min.yml)) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.org/MingweiSamuel/riotapi-schema/builds) daily. *** 
 *
 * OpenAPI spec version: dfa1c0f97b9cc62a43c9fb91daa1b91b3e9485c2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.MatchV4MatchDto;
import io.swagger.client.model.MatchV4MatchTimelineDto;
import io.swagger.client.model.MatchV4MatchlistDto;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MatchV4Api {
    private ApiClient apiClient;

    public MatchV4Api() {
        this(Configuration.getDefaultApiClient());
    }

    public MatchV4Api(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for matchV4GetMatch
     * @param matchId The match ID. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch">Get match by match ID. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchCall(Long matchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/lol/match/v4/matches/{matchId}"
            .replaceAll("\\{" + "matchId" + "\\}", apiClient.escapeString(matchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "X-Riot-Token", "api_key" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call matchV4GetMatchValidateBeforeCall(Long matchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'matchId' is set
        if (matchId == null) {
            throw new ApiException("Missing the required parameter 'matchId' when calling matchV4GetMatch(Async)");
        }
        

        com.squareup.okhttp.Call call = matchV4GetMatchCall(matchId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get match by match ID.
     * Get match by match ID.
     * @param matchId The match ID. (required)
     * @return MatchV4MatchDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch">Get match by match ID. Documentation</a>
     */
    public MatchV4MatchDto matchV4GetMatch(Long matchId) throws ApiException {
        ApiResponse<MatchV4MatchDto> resp = matchV4GetMatchWithHttpInfo(matchId);
        return resp.getData();
    }

    /**
     * Get match by match ID.
     * Get match by match ID.
     * @param matchId The match ID. (required)
     * @return ApiResponse&lt;MatchV4MatchDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch">Get match by match ID. Documentation</a>
     */
    public ApiResponse<MatchV4MatchDto> matchV4GetMatchWithHttpInfo(Long matchId) throws ApiException {
        com.squareup.okhttp.Call call = matchV4GetMatchValidateBeforeCall(matchId, null, null);
        Type localVarReturnType = new TypeToken<MatchV4MatchDto>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get match by match ID. (asynchronously)
     * Get match by match ID.
     * @param matchId The match ID. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch">Get match by match ID. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchAsync(Long matchId, final ApiCallback<MatchV4MatchDto> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = matchV4GetMatchValidateBeforeCall(matchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<MatchV4MatchDto>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for matchV4GetMatchByTournamentCode
     * @param tournamentCode The tournament code. (required)
     * @param matchId The match ID. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode">Get match by match ID and tournament code. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchByTournamentCodeCall(String tournamentCode, Long matchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}"
            .replaceAll("\\{" + "tournamentCode" + "\\}", apiClient.escapeString(tournamentCode.toString()))
            .replaceAll("\\{" + "matchId" + "\\}", apiClient.escapeString(matchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "X-Riot-Token", "api_key" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call matchV4GetMatchByTournamentCodeValidateBeforeCall(String tournamentCode, Long matchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'tournamentCode' is set
        if (tournamentCode == null) {
            throw new ApiException("Missing the required parameter 'tournamentCode' when calling matchV4GetMatchByTournamentCode(Async)");
        }
        
        // verify the required parameter 'matchId' is set
        if (matchId == null) {
            throw new ApiException("Missing the required parameter 'matchId' when calling matchV4GetMatchByTournamentCode(Async)");
        }
        

        com.squareup.okhttp.Call call = matchV4GetMatchByTournamentCodeCall(tournamentCode, matchId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get match by match ID and tournament code.
     * Get match by match ID and tournament code.
     * @param tournamentCode The tournament code. (required)
     * @param matchId The match ID. (required)
     * @return MatchV4MatchDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode">Get match by match ID and tournament code. Documentation</a>
     */
    public MatchV4MatchDto matchV4GetMatchByTournamentCode(String tournamentCode, Long matchId) throws ApiException {
        ApiResponse<MatchV4MatchDto> resp = matchV4GetMatchByTournamentCodeWithHttpInfo(tournamentCode, matchId);
        return resp.getData();
    }

    /**
     * Get match by match ID and tournament code.
     * Get match by match ID and tournament code.
     * @param tournamentCode The tournament code. (required)
     * @param matchId The match ID. (required)
     * @return ApiResponse&lt;MatchV4MatchDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode">Get match by match ID and tournament code. Documentation</a>
     */
    public ApiResponse<MatchV4MatchDto> matchV4GetMatchByTournamentCodeWithHttpInfo(String tournamentCode, Long matchId) throws ApiException {
        com.squareup.okhttp.Call call = matchV4GetMatchByTournamentCodeValidateBeforeCall(tournamentCode, matchId, null, null);
        Type localVarReturnType = new TypeToken<MatchV4MatchDto>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get match by match ID and tournament code. (asynchronously)
     * Get match by match ID and tournament code.
     * @param tournamentCode The tournament code. (required)
     * @param matchId The match ID. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode">Get match by match ID and tournament code. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchByTournamentCodeAsync(String tournamentCode, Long matchId, final ApiCallback<MatchV4MatchDto> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = matchV4GetMatchByTournamentCodeValidateBeforeCall(tournamentCode, matchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<MatchV4MatchDto>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for matchV4GetMatchIdsByTournamentCode
     * @param tournamentCode The tournament code. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode">Get match IDs by tournament code. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchIdsByTournamentCodeCall(String tournamentCode, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids"
            .replaceAll("\\{" + "tournamentCode" + "\\}", apiClient.escapeString(tournamentCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "X-Riot-Token", "api_key" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call matchV4GetMatchIdsByTournamentCodeValidateBeforeCall(String tournamentCode, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'tournamentCode' is set
        if (tournamentCode == null) {
            throw new ApiException("Missing the required parameter 'tournamentCode' when calling matchV4GetMatchIdsByTournamentCode(Async)");
        }
        

        com.squareup.okhttp.Call call = matchV4GetMatchIdsByTournamentCodeCall(tournamentCode, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get match IDs by tournament code.
     * Get match IDs by tournament code.
     * @param tournamentCode The tournament code. (required)
     * @return List&lt;Long&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode">Get match IDs by tournament code. Documentation</a>
     */
    public List<Long> matchV4GetMatchIdsByTournamentCode(String tournamentCode) throws ApiException {
        ApiResponse<List<Long>> resp = matchV4GetMatchIdsByTournamentCodeWithHttpInfo(tournamentCode);
        return resp.getData();
    }

    /**
     * Get match IDs by tournament code.
     * Get match IDs by tournament code.
     * @param tournamentCode The tournament code. (required)
     * @return ApiResponse&lt;List&lt;Long&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode">Get match IDs by tournament code. Documentation</a>
     */
    public ApiResponse<List<Long>> matchV4GetMatchIdsByTournamentCodeWithHttpInfo(String tournamentCode) throws ApiException {
        com.squareup.okhttp.Call call = matchV4GetMatchIdsByTournamentCodeValidateBeforeCall(tournamentCode, null, null);
        Type localVarReturnType = new TypeToken<List<Long>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get match IDs by tournament code. (asynchronously)
     * Get match IDs by tournament code.
     * @param tournamentCode The tournament code. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode">Get match IDs by tournament code. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchIdsByTournamentCodeAsync(String tournamentCode, final ApiCallback<List<Long>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = matchV4GetMatchIdsByTournamentCodeValidateBeforeCall(tournamentCode, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<List<Long>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for matchV4GetMatchTimeline
     * @param matchId The match ID. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline">Get match timeline by match ID. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchTimelineCall(Long matchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/lol/match/v4/timelines/by-match/{matchId}"
            .replaceAll("\\{" + "matchId" + "\\}", apiClient.escapeString(matchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "X-Riot-Token", "api_key" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call matchV4GetMatchTimelineValidateBeforeCall(Long matchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'matchId' is set
        if (matchId == null) {
            throw new ApiException("Missing the required parameter 'matchId' when calling matchV4GetMatchTimeline(Async)");
        }
        

        com.squareup.okhttp.Call call = matchV4GetMatchTimelineCall(matchId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get match timeline by match ID.
     * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
     * @param matchId The match ID. (required)
     * @return MatchV4MatchTimelineDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline">Get match timeline by match ID. Documentation</a>
     */
    public MatchV4MatchTimelineDto matchV4GetMatchTimeline(Long matchId) throws ApiException {
        ApiResponse<MatchV4MatchTimelineDto> resp = matchV4GetMatchTimelineWithHttpInfo(matchId);
        return resp.getData();
    }

    /**
     * Get match timeline by match ID.
     * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
     * @param matchId The match ID. (required)
     * @return ApiResponse&lt;MatchV4MatchTimelineDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline">Get match timeline by match ID. Documentation</a>
     */
    public ApiResponse<MatchV4MatchTimelineDto> matchV4GetMatchTimelineWithHttpInfo(Long matchId) throws ApiException {
        com.squareup.okhttp.Call call = matchV4GetMatchTimelineValidateBeforeCall(matchId, null, null);
        Type localVarReturnType = new TypeToken<MatchV4MatchTimelineDto>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get match timeline by match ID. (asynchronously)
     * Get match timeline by match ID. ## Implementation Notes Not all matches have timeline data.
     * @param matchId The match ID. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline">Get match timeline by match ID. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchTimelineAsync(Long matchId, final ApiCallback<MatchV4MatchTimelineDto> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = matchV4GetMatchTimelineValidateBeforeCall(matchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<MatchV4MatchTimelineDto>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for matchV4GetMatchlist
     * @param encryptedAccountId The account ID. (required)
     * @param champion Set of champion IDs for filtering the matchlist. (optional)
     * @param queue Set of queue IDs for filtering the matchlist. (optional)
     * @param season Set of season IDs for filtering the matchlist. (optional)
     * @param endTime The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param beginTime The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param endIndex The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @param beginIndex The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist">Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchlistCall(String encryptedAccountId, List<Integer> champion, List<Integer> queue, List<Integer> season, Long endTime, Long beginTime, Integer endIndex, Integer beginIndex, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/lol/match/v4/matchlists/by-account/{encryptedAccountId}"
            .replaceAll("\\{" + "encryptedAccountId" + "\\}", apiClient.escapeString(encryptedAccountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (champion != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "champion", champion));
        if (queue != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "queue", queue));
        if (season != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "season", season));
        if (endTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("endTime", endTime));
        if (beginTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("beginTime", beginTime));
        if (endIndex != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("endIndex", endIndex));
        if (beginIndex != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("beginIndex", beginIndex));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "X-Riot-Token", "api_key" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call matchV4GetMatchlistValidateBeforeCall(String encryptedAccountId, List<Integer> champion, List<Integer> queue, List<Integer> season, Long endTime, Long beginTime, Integer endIndex, Integer beginIndex, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'encryptedAccountId' is set
        if (encryptedAccountId == null) {
            throw new ApiException("Missing the required parameter 'encryptedAccountId' when calling matchV4GetMatchlist(Async)");
        }
        

        com.squareup.okhttp.Call call = matchV4GetMatchlistCall(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param encryptedAccountId The account ID. (required)
     * @param champion Set of champion IDs for filtering the matchlist. (optional)
     * @param queue Set of queue IDs for filtering the matchlist. (optional)
     * @param season Set of season IDs for filtering the matchlist. (optional)
     * @param endTime The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param beginTime The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param endIndex The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @param beginIndex The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @return MatchV4MatchlistDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist">Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. Documentation</a>
     */
    public MatchV4MatchlistDto matchV4GetMatchlist(String encryptedAccountId, List<Integer> champion, List<Integer> queue, List<Integer> season, Long endTime, Long beginTime, Integer endIndex, Integer beginIndex) throws ApiException {
        ApiResponse<MatchV4MatchlistDto> resp = matchV4GetMatchlistWithHttpInfo(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex);
        return resp.getData();
    }

    /**
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param encryptedAccountId The account ID. (required)
     * @param champion Set of champion IDs for filtering the matchlist. (optional)
     * @param queue Set of queue IDs for filtering the matchlist. (optional)
     * @param season Set of season IDs for filtering the matchlist. (optional)
     * @param endTime The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param beginTime The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param endIndex The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @param beginIndex The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @return ApiResponse&lt;MatchV4MatchlistDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist">Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. Documentation</a>
     */
    public ApiResponse<MatchV4MatchlistDto> matchV4GetMatchlistWithHttpInfo(String encryptedAccountId, List<Integer> champion, List<Integer> queue, List<Integer> season, Long endTime, Long beginTime, Integer endIndex, Integer beginIndex) throws ApiException {
        com.squareup.okhttp.Call call = matchV4GetMatchlistValidateBeforeCall(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, null, null);
        Type localVarReturnType = new TypeToken<MatchV4MatchlistDto>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. (asynchronously)
     * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. ## Implementation Notes A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.  If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
     * @param encryptedAccountId The account ID. (required)
     * @param champion Set of champion IDs for filtering the matchlist. (optional)
     * @param queue Set of queue IDs for filtering the matchlist. (optional)
     * @param season Set of season IDs for filtering the matchlist. (optional)
     * @param endTime The end time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param beginTime The begin time to use for filtering matchlist specified as epoch milliseconds. If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. (optional)
     * @param endIndex The end index to use for filtering matchlist. If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @param beginIndex The begin index to use for filtering matchlist.  If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * Official API Reference
     * @see <a href="https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist">Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any. Documentation</a>
     */
    public com.squareup.okhttp.Call matchV4GetMatchlistAsync(String encryptedAccountId, List<Integer> champion, List<Integer> queue, List<Integer> season, Long endTime, Long beginTime, Integer endIndex, Integer beginIndex, final ApiCallback<MatchV4MatchlistDto> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = matchV4GetMatchlistValidateBeforeCall(encryptedAccountId, champion, queue, season, endTime, beginTime, endIndex, beginIndex, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<MatchV4MatchlistDto>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
